# Отчет по лабораторной работе №4
## по курсу "Логическое программирование"

## Обработка естественного языка

### студент: Орусский В.Р.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |                   |
| Левинская М.А.|              |                   |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*
Добавить в отчет грамматику
## Введение

Анализ любого естественного языка - трудоёмкое и сложное дело, которое подразумевает установку в нём определённых правил и ограничений. Например, где начинается слово, как его обрабатывать, как обрабатывать какие-либо операторы, если они в нём имеются и так далее.

Грамматика обычно описывает правила для построения предложений в том или ином языке, однако она зачастую не отображает весь спектр предложений в языке (либо указывает на них не очень явно) + человек не может запомнить огромное множество всех правил грамматик какого-нибудь естественного языка (например нашего русского языка), это просто невозможно. 

В этой ЛР нам предстоит поработать с обработкой выражений, написанных на естественной языке, а то есть перебирать саму строку и отталкиваться от текущего символа в ней.

## Задание

6. Реализовать синтаксический анализатор логического выражения и вычислить
его значение. В выражение допустимы операции отрицания, дизъюнкции,
конъюнкции, следования. {~, V, &, =>}. Истинные считаются только термы
заданы фактами вида
true(river_volga).
true(pupil_vasia).
************
`Запрос: ?-calculate(‘(‘,false,‘V’, river_volga,’)’ & true], X).
Результат: X=true.`

## Принцип решения

Граматика языка содержит следующие атомы:
- логические операторы(~, V, &, =>)
- Переменные(true, false + любая переменная, определённая в true(X))
- Скобки({'(', ')'})

Принцип решения строится на прохождении передданого нам выражения и обработки последовательно троек символов в ней. Почему именно тройки? Потому что нам необходимо проходя по строке параллельно вычислять значение каждого простого выражения, которое мы встретит, а простейшее выражение состоит из 3 символов, двух операндов и оператора.

То есть, как только мы встретим выражение вида: A <operator> B,
где A,B - простые выражения, мы обработаем её и подставим полученное значение true/false в список для дальнейшей обработки.

### Пример вычисления простой формы:
``` prolog
solver([A,'&',B | T], Res):-
	true(A),
	true(B),
	isvar(A),
	isvar(B),
	solver([true|T],Res),
	!.
solver([A,'&',B | T], Res):-
	isvar(A),
	isvar(B),
	solver([false|T],Res).
```
В данном предикате мы обрабатываем логическое И. A и B это переменные слева и справа от оператора соответственно. Далее мы проверяем переменные на валидность и на истинность. 
Если вдруг в A или B попадает скобка или другой оператор, то это вызовет false.

### Проверка истинности и валидации:
```prolog
true(river_volga).
true(pupil_vasya).
true(true).
isvar(X):-
	X \= '(',
	X \= ')',
	X \= '&',
	X \= '=>',
	X \= '~',
	X \= 'V'.
```

Если мы не можем найти простую форму то, мы рекурсивно пропускаем один знак, подразумевая вложенную структуру A & B, где B предсталяет собой сложную структуру, например ~(C=>D).
### Рекурсивный обход:
```prolog
solver([A|[B|T]],Res):-
	solver([B|T],Y),
	[B|T] \= Y,
	solver([A|Y],Res),!.
```
По сути это рекурсивное возвращение к подсчёту строки после того, как мы подсчитали все простейшие формы.
## Результаты

```
?- calculate(['(','river_volga','&',true,')','&',true],RES).
RES = true.

?- calculate([false,'&','(','(','river_volga','&',true,')','&',true,')'],RES).
RES = false.
```

## Выводы

Помнится мне, мы подобную задачу реализовывали ещё на 1 курсе с помощью конечных автоматов на Си. Будет интересно сравнить трудоёмкость и очевидность решения там и в этом ЛР.
А ещё, сама задача ну очень напоминает мне алгоритм Бауэра-Замельзона, с тем лишь отличием, что у меня не учитывается приоритетность операторов и скобок.

При выполнении данной работы, я в очередной раз столкнулся с тем, что пролог не прощает невнимательность или просчёты. Ему нужна строгость, которая будет учитывать все возможные варианты и условия, если забыть хотя бы про один (Например, про обёрнутую в скобки true), то можно долго ломать голову, а что же пошло не так...

Но в тоже время это самый главный плюс пролога, он принимает строгие правила и следуя им, перебирает любые значения. Безусловно это плюс при работе с языком, НО только если этот язык состоит из какого-либо малого кол-ва возможных символов, слов или исходный язык урезан (как в нашем случае) и тд. Когда речь идёт о полноценных естественных языках (русский, английский), пролог всё равно сможет перебрать все возможные состояния, я в этом уверен, но я не уверен, что сможет разработчик. Посему считаю, что для полноценного анализа естественных языков на несколько голов выше машинное обучение, которое сейчас активно популяризируется.

Более того, прологу ещё нужно объяснить, что то или иное слово - является словом в данном языке (как я делал с какими-либо высказываниями, я им передавал значени true, вот так придётся сделать со всеми возможными словами в естественном языке, а это... Немного долго выйдет по времени). И как я говорил в начале, хотел бы сравнить написание на прологе и на Си. Так вот, к моему же удивлению... На Си это было сделать сложнее, причём намного (да понятно, что там массивы char, с чарами работать не очень комфортно и так далее), но пролог тут одержал 100% победу, в нём работать со сторовыми литерами, их обработка и подстановка в разы проще.
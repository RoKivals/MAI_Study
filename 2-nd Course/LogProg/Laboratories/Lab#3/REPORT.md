# Отчет по лабораторной работе №3
## по курсу "Логическое программирование"

## Решение задач методом поиска в пространстве состояний

### студент: Орусский В.Р.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В.     |              |               |
| Левинская М.А.    |              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение
Ещё в начале нашего курса по логическому программированию, нам говорили о том, что пролог предназначен и способен решать задачи ИИ. В данной лабораторной работе нас ожидает именно такого рода задача. Нам предстоить найти путь из одного состояния в какое-то определённое конечное за наименьшее число шагов.
Так же для работы нам понадобится система состояний и алгоритмы поиска в ней. Систему состояний мы можем построить, как граф и использовать довольно известные методы поиска в глубину и в ширину.
И что самое интересное, граф в прологе по идее должно быть построить проще, нежели в классических ЯП, поскольку граф - предикат перехода от одного состояний к другому, а пролог уже сам сможет перебрать все эти вариации переходов и тем самым выстроить граф.

## Задание

Вариант 8:

Вдоль доски расположены лунки, в каждой из которых лежит красный, белый или синий шар. Одним ходом можно менять местами два любых шара. Добиться того, чтобы сначала шли все красные шары, все синие - последними, а белые - посередине. Решить задачу за наименьшее число ходов.

## Принцип решения

Как уже говорилось, мы будем использовать систему состояний, представленную в виде графа, а сам граф будет реализовываться с помощью предиката перехода между состояниями (в моей ЛР этот функционал выполняется предикатами move и prolong).

И с помощью предиката move мы перебираем различные перестановки 2 элементов в списке, отсеивая бессмысленные (когда уже элементы отсортированы).

В конечном итоге, мы получаем граф состояний и в нём нам нужнло перейти из исходного состояния в какое-то конечное состояние, чтобы найти это самое состояние мы будем использовать различные алгоритмы поиска внутри графа.

Предикат валидности перехода:
```prolog
less(r, w).
less(w, b).
less(r, b).
```
Поиск в глубину:
Дерево решений выглядит как проход от корня до всех листьев, от очередного листа возвращаемся бектрекингом. В итоге первый путь не обязательно будет кратчайшим. 

```prolog
path1([T|P],T,[T|P]).
path1(X,T,H) :- prolong(X,Y), path1(Y,T,H).
path_dfs(X,T,H) :- path1([X],T,L), reverse1(L,H).
```

Поиск в ширину:
Находим все пути (`findall`), да он более массивный и время дольше, но зато 100% находим кратчайший путь.
```prolog
path2([[T|P]|_],T,[T|P]).
path2([X|P],T,G) :- findall(P1,prolong(X,P1),L), append1(P,L,Y), !, path2(Y,T,G).
path2([_|P],T,G) :- path2(P,T,G).
path_bfs(X,T,G):- path2([[X]],T,L), reverse1(L,G).
```

Поиск в глубину с итеративным погружением:
Когда мы дошли до конечной вершины, параметр глубины (`DepthLimit`) равен `0` для отсечения тех путей, которые не точно соответствуют нашей глубине. Соответственно при этом первым ответом мы получим кратчайший путь. Сам алгоритм похож на поиск в глубину.
```prolog
path3([T|P],T,[T|P],0).
path3(X,T,H,N) :- N > 0, prolong(X,Y), N1 is N-1, path3(Y,T,H,N1).
search_id(S,F,P,DL) :- path3([S],F,P,DL).
search_id(S,F,P) :- integer1(Level), search_id(S,F,P,Level).
path_id(S,F,P) :- search_id(S,F,K), reverse1(K,P).
```

## Результаты

| Алгоритм поиска | Длина найденного пути | Время работы |   |   |
|-----------------|-----------------------|--------------|---|---|
| В глубину       | 9                     | 0.000        |   |   |
| В ширину        | 9                     | 1.215        |   |   |
| ID              | 9                     | 0.031        |   |   |

Измерения времени производились с помощью предиката `time`.

## Выводы
Данная лабораторная работа была крайне необычной и сложной. Я привык работать с большими СД в классических ЯП, но в Прологе это стало для меня новшеством. Я поработал с представлением графа через предикаты и с методами поиска в нём. (В глубину, в ширину и итеративный).

Наглядно результаты всех обходов видно в табличке выше. Они все дали нужный ответ, в глубину - самый быстрый, оно и понятно, его суть показать, есть ли решение хотя бы одно. Самый долгий - поиск в ширину, он самый надёжный и ищет самый короткий путь, но он полный и перебирает абсолютно весь граф, на что уходит гораздо больше времени.

Ну и раз мы коснулись ИИ в данной ЛР, считаю, что Пролог проще и быстрее для написания подобных алгоритмов поиска решений, однако в разы менее понятный и расширяемый для дальнейшего поддержания кода. А в целом очень полезная лабораторная работа.
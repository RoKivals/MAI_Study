# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Иванопуло А.Б.

## Результат проверки

| Преподаватель     | Дата 07.10.22|  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение
В прологе списки являются структурой, которая состоит из двух частей:
1) Голова (Первый элемент).
2) Хвост (Все последующие элементы списка).
При итерировании списка элемент хвоста становится головой, а все последующие за ним становятся хвостом. (Очень грубое объяснение).

Список похож на односвязный список из других ЯП.
## Задание 1.1: Предикат обработки списка
Вариант №16.
Нахождение номера первого вхождения элемента с заданным значением. 

Предикат:
`index(L, Elem, N)` - Предикат обходит список от начала до заданного элемента и вычисляет его номер.

Примеры использования:
```prolog
index([1,3,4,5,9,1,3], 3, X). 
X = 2.

index([1,3,4,5,9,1,3], 9, X). 
X = 5.
```

Реализация:
```prolog
% Без использования стандартных предикатов
index([Elem|_], Elem, 1).
index([_|T], Elem, Count):- index(T, Elem, Count1), Count is Count1 + 1,  !.

% С использованием стандартных предикатов
index_2(L, Elem, N):-
    append(T, [Elem|_], L), append(T, [Elem], T1), length(T1, N), !.
...
```

`index` Работает следующий образом: Мы проходим по списку от начала до конкретного элемента `Elem`. На каждой итерации счётчик увеличивается на 1. В моменте, где мы встречаем наш элемент, счётчик равен 1.

`index_2` в свою очередь проходится по всем элементам от начала до `Elem` и добавляет их в новый список. После чего, считается длина полученного списка.

## Задание 1.2: Предикат обработки числового списка

Вариант №1. 
Вычисление суммы элементов.

Предикат:
`sum(List, Count).` - проходит по всему списку и подсчитывает его сумму прибавлением к счётчику `Count` значения головы.

Примеры использования:
```prolog
sum([1,4,5,9,0,1], Sum).
Sum = 20.

sum_t([1,5,8,9,10,15], Sum).
Sum = 48.
```

Реализация:
```prolog
% Обход списка
sum([], 0).
sum([A|T], Sum):- sum(T,  Sum1), Sum is Sum1 + A.

% Хвостовая рекурсия
sum_t(L, S):- sum_t(L, 0, S).
sum_t([], R, R):- !.
sum_t([H|T], Sum, R):- Sum1 is Sum + H, sum_t(T, Sum1, R).
...
```


`sum` - проходит по всему списку, прибавляя к счётчику `Sum` значение головы списка в данный момент. На след итерации мы обращаемся к хвосту и так до тех пор, пока список не закончится. Изначально счётчик равен 0.

`sum_t` впринципе работает рубль в рубль так же, как и первый предикат за тем лишь исключением, что в нём используется [хвостовая рекурсия](https://ru.wikipedia.org/wiki/Хвостовая_рекурсия).

## Задание 2: Реляционное представление данных

Из плюсов:

>1. Реляционное представление чаще всего интуитивно понятно даже для простого обывателя. Потому что с таблицами человек встречается везде где только возможно.
>2. Легко осваеваемые ЯП для работы с данными.
>3. Независимость ПО от данных. => При изменении данных в БД чаще всего никак не меняется логика программы (если она изначально была нормально спроектирована).

Минусы:
>1. Lалеко не всегда предметная область может быть представлена в виде "таблиц".
>2. Занимает много дискового пространства.
>3. Трудоёмкость разработки.
>4. Самый медленный доступ к памяти.

Вариант 1. Представление 4.

Задание 1.
Получить таблицу групп и средний балл по каждой из групп.

Предикаты:
`sum(List, Sum)` - считает сумму элементов списка `List`.
`avg(List, Res)` - считает среднее арифметическое значений списка `List`.
`grades(Student, N)` - выдаёт все оценки конкретного студента `Student`.
`stud_to_overall_avg(Student, Res)` - сред. арифм. по всем предметам одного студента `Student`.
`group_to_every_studs_avg(Group, Res)` - средний балл каждого студента в группе `Group`.
`groups_avg()` - средний балл каждой группы.

Пример использования:
``` prolog
groups_avg().
Группа №102, средний бал: 3.9444444444444446
Группа №101, средний бал: 3.9666666666666672
Группа №104, средний бал: 3.861111111111111
Группа №103, средний бал: 4.145833333333334
```

Реализация:
```prolog
    % Считает сумму. Используется для вычисления среднего.
    sum([], 0).
    sum([X|Y], S) :- sum(Y, S1), S is S1 + X.

    % Считает среднее. Используется для подсчета среднего балла.
    avg(L, R) :- 
    length(L, Len), 
    sum(L, Sum), R is Sum / Len.

    % Выдает оценки все студента. 
    grades(Student, N) :- 
    subject(_, X), 
    member(grade(Student, N), X).

    % Среднее по всем предметам, оценкам определенного студента.
    stud_to_overall_avg(Student, Res) :- 
    findall(N, grades(Student, N), List), avg(List, Res).

    % Средний балл каждого студента в определенной группе.
    group_to_every_studs_avg(Group, Res) :- 
    group(Group, StudList), 
    member(Stud, StudList), 
    stud_to_overall_avg(Stud, Res).

    % В каждой группе считаем сумму средних баллов всех ее студентов. Считаем среднее арифм. этой суммы. Выводим результат.
    groups_avg() :- 
        group(Group, _), 
        findall(Res, group_to_every_studs_avg(Group, Res), ListValue),
        avg(ListValue, Ans),
    write('Группа №'), write(Group), write(', средний бал: '), write(Ans), write('\n'), fail.
...
```

Задание 2.
Для каждого предмета получить список студентов, не сдавших экзамен (grade=2).


Предикаты:
`subj_to_failed_studs(Subj, Name)` - имена студентов, у которых двойки по предмету `Subj`.
`subj_failed()` - по каждому предмету выводит список несдавших студентов. 


Пример использования:
``` prolog
subj_failed().
Предмет "Логическое программирование" не сдали: [Петровский,Сидоров,Джаво]
Предмет "Математический анализ" не сдали: [Петров]
Предмет "Функциональное программирование" сдали все!
Предмет "Информатика" не сдали: [Сиплюсплюсов,Криптовалютников]
Предмет "Английский язык" не сдали: [Решетников,Азурин]
Предмет "Психология" не сдали: [Безумников,Круглосчиталкин]
```

Реализация:
```prolog
% Находит имена студентов, имеющих двойки по опред. предмету
    subj_to_failed_studs(Subj, Name) :-
        subject(Subj, Students),
        member(grade(Name, 2), Students).

    % По каждому предмету выводит список несдавших его студентов, если такие имеются
    subj_failed() :-
        subject(Subj, _),
        findall(Name, subj_to_failed_studs(Subj, Name), List),
        length(List, ListLen),
        write('Предмет "'), write(Subj), 
            ((ListLen \= 0, write('" не сдали: '), write(List), write('\n'));
            (ListLen == 0, write('" сдали все!\n'))),
            fail.
...
```

Задание 3.
Найти количество не сдавших студентов в каждой из групп.

Предикаты:
`group_subj_to_failed_studs(Group, Stud)` - имена студентов с пересдачами в группе `Group`.
`group_to_cnt_failed(Group, Cnt)` - Кол-во студентов с пересдачами в группе `Group`. По сути просто sum всех элементов списка из первого предиката.
`cnt_failed()` - кол-во студентов с пересдачами в каждой группе. 

Пример использования:
``` prolog
cnt_failed().
Группа №102, число несдавших: 3
Группа №101, число несдавших: 3
Группа №104, число несдавших: 2
Группа №103, число несдавших: 2
```

Реализация:
```prolog
% Студенты с неудами в опред. группе
    group_subj_to_failed_studs(Group, Stud) :-
        subject(_, GradesList),
        group(Group, StudsList),
        member(Stud, StudsList),
        member(grade(Stud, 2), GradesList).

    % Кол-во студентов с недуами в опред. группе
    group_to_cnt_failed(Group, Cnt) :-
        findall(Name, group_subj_to_failed_studs(Group, Name), List),
        length(List, Cnt).

    % В каждой группе считает число студентов с неудами
    cnt_failed() :-
        group(Group, _),
        group_to_cnt_failed(Group, Cnt),
        write('Группа №'), write(Group), write(', число несдавших: '), write(Cnt), write('\n'), fail.
...
```

## Выводы
Ну начнём с того, что это мой первый опыт программирования на Prolog. До этого я с ним никогда не сталкивался и использовал Python, C++, C#. Пролог оставил у меня неоднозначное впечатление.
1) Он нечитабельный, к каждому предикату нужно написать огромную документацию, чтобы понимать, как он работает.
2) Однако, для каких-то простейших вещей он требует больше кода, чем императивные ЯП, но в то же время, для более сложных вещей тут хватит буквально 3-4 строк.

Так же, полистав гитхаб, узнал, что оказывается на прологе пишут ИИ (это для меня стало "ВАУ"). В процессе работы на лабораторной работой пришёл к выводу о том, что Prolog и правда прекрасен для реализации каких-то логических цепочек, которые можно зациклить. Но к синтаксису и особенностям языка надо ещё привыкнуть. Ну и в конце концов, в результате выполнения ЛР №1 я познакомился с утройством списков в Prolog, их использование в предикатах, познакомился с работой стандартного предиката findall().




# Реферат
## по курсу "Логическое программирование"

### студент: Орусский В.Р.

## ТЕМА

1. Как научить младшую сестру/брата логическому программированию

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

Вот и настал тот день, когда я попробую себя в роли учителя для своего брата или сестры, коих у меня к сожалению нет, а посему условимся на том, что они будут не младше возраста среднестатистического 8-классника и хотя бы иногда посещали уроки информатики в школе. Ну и само собой, поскольку учить Prolog первым языком программирования в жизни я считаю не этично, а я как настоящий брат забочусь о своих родственниках, то будем считать, что мой сегодняшний ученик имеет представление хотя бы об одном императивном языке программирования, неважно будь это C++, Java или даже на худой конец Python.

Исходя из кол-ва требуемых слов я должен не просто рассказать, как научить их, а составить полноценную программу обучения со всеми часами и ещё написать пару лекций... Хочу лишь напомнить, что брат и сестра это скорее всего дети, а они не слушают нудные лекции, не разбираются в математической теории и не знают кучу заумных слов, да я тоже не знаю их особо, но я попробую...

Повествовать о таком замечательном языке логического программирования, как Prolog я буду на примерах из жизни и с аналогией из других языков. Собственно говоря, на наших лекциях было очень много страшных слов из разряда "Унификация, Сколемизация, Резолюция и её стратегии, Дизъюнкты Хорна, Отсечение (вроде парировать никого не придётся), Логика (для некоторых людей это страшно) и даже смерть Сократа" и много много страшных формул и отсылок к дискретной математике. В данном тексте я приложу все усилия, чтобы  объяснить это на пальцах. 

Начнём с того, что логическое программирование это программирование, в котором на первых порах познания его, наша логика сломается. Это нормально, просто надо привыкнуть и держать в голове пару идей, который не свойственны классическому программированию. Во-первых, логическое программирование работает по принципу перебора всех возможных значений тех или иных значений переменных, а следовательно, чтобы получить ответ, нам нужно указать, где этот самый перебор остановить (Но об этом чуть позже). Насколько мы знаем ещё класса из 5, когда мы только начали сталкиваться с различными олимпиадами по математике, информатике, решение в лоб (то есть перебор всех вариантов) - занятие не самое простое, быстрое, а зачастую далеко не самое выполнимое. Потому что если посчитать 1000 разных вариаций на бумаге ещё можно, кое-как, уже начиная биться в конвульсиях, но можно, то когда речь идёт о миллионах вариантов... Казалось бы, процессор, умный и мощный, может обработать и больше вариаций, да, может, но даже он не справится с бесконечным кол-вом вариантов. А следовательно, чтобы получить искомый ответ и как-то показать, где перебор должен заканчиваться, нам необходимо задать определённые рамки, правила, которые не только сократят простор для перебора, но и укажут на то, что именно мы ищем, что и приведёт нас к нужному результату. Эти самые рамки зовутся правилами, именно исходя из правил мы перебирая все варианты получаем нужный ответ. Интересно ещё и то, что логическое программирование отталкивается только от истины, то есть наши правила должны быть построены так, что к правильному ответу можно прийти тогда и только тогда, когда все наши предикаты, выражения являются правдивыми. Однако, на одной лишь правде далеко не уедешь, как в жизни, так и в логическом программировании, немного подумав, можно понять, что для доказательства каких-то утверждений нам понадобится опровержение каких-либо фактов, то есть тот случай, когда факты лживы... Тут то нам на помощь придёт отрицание. Его можно построить двумя способами:

1 - создать предикат, функцию, которая будет утверждать первоначально лживое утверждение.
Например, создать предикать not_member, который говорит о том, что элемент не входит в список.
2 - использовать стандартный предикат языка (not или \+).
Однако, стоит помнить, что отрицание не позволяет генерировать значения. То есть, нельзя получить список недругов, если отрицать предикат друзей. А также, двойное отрицание не даёт нам значений и оно не аналогично отсутствию отрицания (двойное отрицание лучше не использовать). Да и вообще, с отрицанием надо быть осторожнее, ведь при его использовании, ответ может поменяться из-за смены последовательности правил (конъюнкций).

Я уже упомянул такое неизвестное нам слово, как предикат, это довольно просто, по сути это булевая функция (которая возвращает True / False). В неё мы передаём аргументы, обрабатываем их тем или иным образом, чтобы мы получили True (False нас не интересует, но всё же, если после перебора мы так и не дойдём до истины нам выдаст ложь).

Во-вторых, поговорим о том, что же собственно может логическое программирование и Prolog в частности и какие ещё особенности написания реализаций нас ждут.

1) Надо запомнить одно важное правило, в 95% предикатов, которые вы будете писать, вам придётся использовать аргументы, в которых будете хранить те или иные значения (как в случае с передачей аргумента по ссылке в C++). 
То есть вы хотите подсчитать длину списка. Изначально вы думаете, что вам нужен лишь 1 аргумент - сам список, НО нет... Не тут то было, у вас будет и второй аргумент - непосредственно сама длина, которая как бы будет увеличиваться в процессе выполнения предиката. И это правило будет работать почти везде.

2) Для правильного построения логики программмы чаще всего надо будет задавать предикат, в котором есть какие-то определённые конкретные значения аргументов и показывать, какой вывод он даёт - то есть создавать конечную точку перебора.
Пример, вы хотите подсчитать длину списка, но вам надо обязательно задать конечную точку - когда список пуст и его длина равна 0 в этом момент, иначе поиск просто зациклится.

3) Как я уже сказал, мы перебираем различные варианты и сводим этот перебор к минимуму, это означает, что реализуя ту или иную функцию мы можем получить не только искомое значение, а так же и то, которое может к нему привести...
Очень сложная формулировка, понимаю, объясняю проще.
Вот у нас есть математическая формула y = F(x) = $x^2$. Эта функция позволяет нам найти значение y по какому-то x. Например, если x = 2, то y = 4. Но логическое программирование уникально, оно ведь перебирает все возможные варианты x y, а следовательно мы можем получить x, из которых получится y = 4 (это если что ±2). А если мы можем получить значения обеих точек, то это значит, что для логического программирования они обе являются переменными
F(X, Y) - так бы мы записывали данную функцию в языке пролог. И поставив на место Y какую либо цифру, мы бы получили значения X. Это один из огромнейших плюсов логического программирования, по сути мы реализуем сразу две функции, прямую и обратную ей в одной! В классичем программировании я такого не представляю.

4) Из-за того, что логическое программирование является переборным, с его помощью очень легко строить структуры данных по типу деревьев, графов, поскольку перебирая все варианты, пролог как бы создаёт дерево возможных вариаций, то есть выполняя даже самый просто предикат, мы уже работаем с деревом. В сравнении с классическими ЯП, Prolog тут на 3 головы выше.

5) Логическое программирование так же хорошо в том, что оно может изначально представить все возможные варианты параметров в функции, то есть, вы можете передать в предикат абсолютно неизвестные параметры и по правилам, что знает пролог, он подставит все возможные параметры в эту функцию. Вам даже необязательно знать, какой параметр за что отвечает, просто запустите функцию с неизвестными и сразу поймёте (но всё-таки осмысленные названия лучше!).

6) Я уже упомянал о том, что перебор в логическом программировании может идти хоть до бесконечности, а это значит, что у нас есть такое понятие, как backtracing (возврат). Объясняя человеческим языком, мы предположили, что `A` - отец, а потом у нас есть вариант, что либо `B`, либо `C` - его сын, но мы сверились с фактами и поняли, что `B` - сын, тогда согласно возврату, `А` останется отцом, а на роль сына попадёт уже объект `C` и мы будем сверят факт отцовства у `A`с `C`. Таким образом реализуется рекурсия (даже в классическом языке, если начать дебажить рекурсивную функцию, то можно встретиться с этим понятием). Так вот, у нас обязательно будут такие моменты, когда нам хочется найти лишь один, самый первый вариант ответа... Тут нам поможет фишка, под названием отсечение. Отсечение делается с помощью `!`, но тут надо быть аккуратным. Ведь из-за отсечения, мы можем потерять решения. И чаще всего это зависит от типа запроса. Если нам нужно было просто узнать, является ли A отцом, тогда можно отсечь перебор всех детей и это будет называться зелёным отсечением. Но, если запрос подразумевает нахождение всех детей A, то из-за отсечения, мы получим только 1 ребёнка и потеряем всех остальных. В таком случае отсечение зовётся красным. Так же, не стоит забывать о том, что отсечение, как и отрицание не генерирует значения, а лишь управляет перебором.

Помните, я говорил про особенности реализации? Так вот, одним из рекомендованных способов написания кода является рассуждение от результата к началу, то есть, мы отходим от нужного нам значения и пишем функции ОТ него К исходным значениям... Да, нестандартно, ну а что вы хотели?...

А напоследок, мы поговорим о том, где же можно применить логическое программирование:

1) Первое и самое очевидное - искуственный интеллект, ведь Prolog это прямое отражение его концепции - выполнение задач по какому-то набору правил. И да, передав огромное количество правил, мы сможем получить то, что нам нужно, но тут встаёт вопрос о целесообразности... Ведь в прологе это будет намного дольше и менее гибко (тяжело поддерживать в будущем).

2) Обработка текстов, тут пожалуй prolog не сильно уступает классическому программированию, однако, если правил для обработки текста уж очень много, то и соответсвенно программа будет расти, как на дрожжах. 

3) Решение логических задач, задач перебора. Однозначно опережает любой классический ЯП в данной задаче, если нам даны правила и нам нужно что-то по ним найти, то это сразу к прологу.

4) Поиск в графе. В возможностях логического программирования, я уже говорил о том, что с помощью пролога очень легко представлять графы, так вот, совершать поиск в них не менее удобно. Я думаю, что мои брат или сестра изучат в будущем понятие графа и что же за поиск в нём есть, но если говорить просто, то для обхода и поиска решений внутри большой структуры есть различные виды поиска, которые имеют свои плюсы и минусы. Одни выигрывают в скорости, другие в точности, третьи в экономии памяти.

Подводя итог, хочу сказать, что логическое программирование это другая вселенная для программиста на классическом ЯП, погружаясь в неё, ты начинаешь находить, как плюсы, так и заметные минусы. Считаю, что это довольно интересная парадигма, которой каждый должен коснуться и попробовать, ведь порой простота решений тут просто поражает воображение, главное не увлечься слишком сильно и помнить о всех советах и особенностях, упомянутых выше!
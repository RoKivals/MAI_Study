=============================Лабораторная работа #20==============================
Разбор команд терминала Linux.

-----------------------------------CMP--------------------------------------------
Содержимое file2:

Hello
По мостовой
моей души изъезженной
шаги помешанных
вьют жестких фраз пяты.
Где города
повешены
и в петле о́блака
застыли
башен
кривые выи —
иду
один рыдать,
что перекрестком
ра́спяты
городовые.

Содержимое file1:

Hello guys

Результат работы комнады CMP:
rokivals@RoKi:~/Документы/Информатика/Лабы/temp_files$ cmp file1 file2
file1 file2 различаются: байт 6, строка 1

#Мы видим, что команда находит первое отличие между двумя файлами и указывает на то, в какой строке это происходит

rokivals@RoKi:~/Документы/Информатика/Лабы/temp_files$ cmp -b file1 file2
file1 file2 различаются: байт 6, строка 1 равен  40    12 ^J

#Ключ -b даёт нам информацию о самом различии (то есть что лежит в первом и втором файлах). В примере выше сложно понять, поскольку в file2 используется русский алфавит.
#Но если переделать file2 в следующий вид:
Hello Russia

#То мы получим более понятный результат работы этого ключа.
rokivals@RoKi:~/Документы/Информатика/Лабы/temp_files$ cmp -b file1 file2
file1 file2 различаются: байт 7, строка 1 равен 147 g 122 

#Ключ -l даёт нам информацию о всех позициях где есть различия между файлами (с указанием значений байтов):
cmp -l file1 file2
 7 147 122
 9 171 163
11  12 151
cmp: EOF в file1 после байта 11

#Можно использовать ключ -i для того чтобы пропустить сравнение опред. кол-ва байтов в начале.

rokivals@RoKi:~/Документы/Информатика/Лабы/temp_files$ cmp -i 7 file1 file2
file1 file2 различаются: байт 2, строка 1


#В примере выше, мы пропускаем первые 7 байт, то есть команда сравнивает файлы начиная с 8 байта 
(file1 в процессе проверке выглядит как uys, а file2 как ussia) 

P.S. команда используется не только для сравнения текстовых файлов, но также и для изображений и много другого. (предположительно они сравниваются в виде байтовых строк)

-----------------------------------COMM-------------------------------------------
#В целом команда очень похожа на CMP и выполняет функцию сравнения двух файлов (в основном текстовых, поскольку с изображениями или аудиофайлами от неё особо смысла не будет, ведь сортировать по алфавиту
байтовые строки для меня кажется чем-то невозможным).
#Основная особенность её заключается в сравнении файлов по строкам (которые должны быть заранее отсортированы по алфавиту (локали)). 
#В дальнейшем по умолчанию программа выводит 3 раздела. 1 - строки уникальные для первого файла, 2 - для второго и 3 - строки совпадающие в обоих файлах.
#Ключевая особенность из второй строки делает команду очень муторной и не совсем рациональной по моему мнению.

#Теперь наши файлы выглядят так:
===file1===
Hello
Guy
How are you
What

===file2===
Hello
guy
How Are
you
Danke
What

#При попытке вызвать команду COMM для двух файлов мы получим нелепицу и предупреждение об отсутствии сортировки двух файлов:
comm file1 file2
		Hello
	guy
Guy
	How Are
How are you
What
	you
comm: данные файла 2 не отсортированы
	Danke
	What

#Поэтому, поскольку я ленивый, да и все тоже, прибегнем к сортировке этих файлов с помощью команды sort (её в дальнейшем подробнее изучим).
#Ключ -о позволяет выводить результат в файл, поэтому просто пишем 
sort file1 -o file1
sort file2 -o file2

И получаем мы: 
===file1===
Guy
Hello
How are you
What
===file2===
Danke
guy
Hello
How Are
What
you

#А дальше работаем с COMM.

comm file1 file2
	Danke
	guy
Guy
		Hello
	How Are
How are you
		What
	you

# Обычный вывод comm, ничего непонятно, не так ли?

А если вот так?
 1      2   3
	  Danke
	   guy
Guy
		    Hello
	  How Are 
How are you
		    What
	   you

#Это и есть распределение на 3 группы, о которых шла речь в начале.
#C помощью ключей мы можем исключить вывод того или иного столбца
#Например, ключ -12 оставит нам исключительно столбец одинаковых строк:
rokivals@RoKi:~/Документы/Информатика/Лабы/temp_files$ comm -12 file1 file2
Hello
What
#На самом деле функционал команды на этом и заканчивается, однако есть один интересный ключ, который поможет в восприятии этой команды.
# --output-delimiter=STR данный ключ отделяет столбы друг от друга с помощью STR:

rokivals@RoKi:~/Документы/Информатика/Лабы/temp_files$ comm file1 file2 --output-delimiter " ----- "
 ----- Danke
 ----- guy
Guy
 -----  ----- Hello
 ----- How Are
How are you
 -----  ----- What
 ----- you

#С помощью данной команды можно легко визуализировать эти столбцы и вывод становится понятнее внешне.

#А также есть ключ, который решит все проблемы с сортировкой, --nocheck-order, который позволяет не проверять сортировку файлов по алфавиту.
#Есть и обратный ему ключ, который указывает, что проверку надо обязательно провести. (--check-order)


comm file1 file2 --check-order --output-delimiter "----"
----Danke
Guy
--------Hello
comm: данные файла 2 не отсортированы


comm file1 file2 --nocheck-order --output-delimiter "----"
----Danke
Guy
--------Hello
----guy
----How Are
How are you
--------What
----you


P.S. Последние две команды применялись к одним и тем же файлам (они были изменены, дабы создать условие отсутствия сортировки).


-----------------------------------WC---------------------------------------------
#Максимально простая и где-то полезная команда, которая считает кол-во слов, строк и байтов информации в файле, в самом конце пишется название самого файла.
#Если передать команде в параметры несколько файлов, будет также произведён подсчёт общего кол-ва строк, слов и байтов.
#Также можно применить к файлам различного типа, но там полезнее всего будет информация о байтах (вес картинки или аудио).

Пример работы на данных файлах:
===file1===
Guy
Hello
How are you
What

===file2===
Danke
Hello
guy
How Are
What
you
---------------------------

wc file1
 4  6 27 file1

wc file2
 6  7 33 file2

wc file1 file2

 4  6 27 file1
 6  7 33 file2
10 13 60 итого

#Ключи позволяют нам получить отдельно значения строк, слов, но самый полезный ключ (-m or --count) позволяет получить кол-во симолов в файле

wc -m file1 file2
27 file1
33 file2
60 итого

#Здесь оно совпадает с кол-вом байт, поскольку одна буква кодируется одним байтом.

wc -cm ~/Загрузки/index.jpeg 
3255 5843 /home/rokivals/Загрузки/index.jpeg

#Вот более показательный пример на байтовом представлении картинки, где кол-во символов равно 3255, а размер в байтах 5843.

#Остальные ключи просто выводят то, что мы и так получаем в стандартном выводе (-l = строки, -w = кол-во слов, -c = кол-во байт)
#Также, стоит помнить о том, что вывод осуществляется в формате: Строки - Слова - Байты - Название файла.

-----------------------------------DD---------------------------------------------
#Команда - аналог CP (команда копирования), которая позволяет работать с ОЧЕНЬ большими размерами данных (целые жёсткие диски) и при этом работать достаточно быстро.
#Скорость работы увеличивается засчёт использования блочной структры (то есть необходимые данные переносятся блоками опред размеров, которые можно задать с помощью параметра).
#Поскольку в Linux всё является файлом (даже устройство), то с помощью DD можно перенести устройство в файл и наоборот (зачем и для чего я не знаю, но так можно).
#Как уже говорилось, есть параметр для указания размера блоков (bs). Чтобы передать ему значение надо использовать след таблицу:
    с - один символ;
    b - 512 байт;
    kB - 1000 байт;
    K - 1024 байт;
    MB - 1000 килобайт;
    M - 1024 килобайт;
    GB - 1000 мегабайт;
    G - 1024 мегабайт.

#2b = 1 Килобайт, поэтому на первый взгляд система довольно запутанная, но понять её можно, если постоянно ссылаться на табличку.

dd if=~/Загрузки/index.jpeg of=../temp_files/index.jpeg bs=100c
58+1 записей получено
58+1 записей отправлено
5843 байт (5,8 kB, 5,7 KiB) скопирован, 0,000180983 s, 32,3 MB/s

dd if=~/Загрузки/index.jpeg of=../temp_files/index.jpeg
11+1 записей получено
11+1 записей отправлено
5843 байт (5,8 kB, 5,7 KiB) скопирован, 0,000207447 s, 28,2 MB/s

#По умолчанию, размер блока составляет 512 байт, на тестах выше видно, что со значением по умолчанию было отправлено в 5 раз меньше блоков, нежели с значением в 100 байт (поскольку у нас 1 символ == 1 байту).
#Также полезен параметр count, которые указывает необходимое кол-во блоков для копирования (размер блока задаётся в bs).
#Вообще, назначением команды DD является создание и работа с очень большими размерами данных (целыми дисками), чаще всего - копирование дисков или удаление всех файлов с него и так далее.
#Стоит отметить, что dd работает с битовым представлением файлов, поэтому с её помощью можно легко записать нули на весь диск, тем самым затерев все данные на нём.
Это делается вот так: dd if=/dev/zero of=/dev/sdb (я это проверил на изображении, по итогу остаётся просто пустая картинка без содержимого, которую нельзя открыть, так она ещё и весит 1.3 GB, 
как такое возможно, я не знаю...

wc index.jpeg 
         0          0 1251502592 index.jpegdd if=/dev/zero of=image.crypted bs=1MB count=1000
1000+0 записей получено
1000+0 записей отправлено
1000000000 байт (1,0 GB, 954 MiB) скопирован, 27,0457 s, 37,0 MB/s


#Вот пример работы count. Стоит упомянуть, что если bs взят настолько большим, что указанное кол-во блоков слишком много для файла, то будет использовано блоков меньше.
#Если же bs * count меньше размера самого файла (диска) то соответственно будет перенесён не весь файл (диск), а лишь его опред часть (два примера ниже).

dd if=~/Загрузки/index.jpeg of=../temp_files/index.jpeg bs=10c count=100
100+0 записей получено
100+0 записей отправлено
1000 байт (1,0 kB) скопирован, 0,000233713 s, 4,3 MB/s


dd if=~/Загрузки/index.jpeg of=../temp_files/index.jpeg bs=1c count=100
100+0 записей получено
100+0 записей отправлено
100 байт скопировано, 0,000208607 s, 479 kB/s

#Данная команда также может быть эффективно использована для создания образа дисков или генерации больших файлов (заполнение нескольких ГБ нулями).
dd if=/dev/zero of=image.crypted bs=1MB count=1000
1000+0 записей получено
1000+0 записей отправлено
1000000000 байт (1,0 GB, 954 MiB) скопирован, 27,0457 s, 37,0 MB/s
#Выглядит это примерно так и занимает много времени (относительно конечно).
-----------------------------------DIFF-------------------------------------------
#Ещё одна команда для сравнения файлов. Она показывает, как из одного файла получить другой.
#То есть какие строки надо добавить или убрать, чтобы получить идентичный файл. Чем-то отдалённо напоминает процесс разрешения конфликтов при слиянии веток в Git.
#Ключ -q позволяет использовать diff просто для понимания, различны ли файлы. По сути, работает как cmp, но без вывода информации о различиях.

diff -q file1 file2
Файлы file1 и file2 различаются

#Ключ -s выводит информацию о том идентичны ли файлы (по умолчанию данная информация не выводится).
===file1===
Guy
Hello
How are you
What

===file3===
Guy
Hello
How are you
What
------------------------------
rokivals@RoKi:~/Документы/Информатика/Лабы/temp_files$ diff file1 file3 #ничего не выводит
rokivals@RoKi:~/Документы/Информатика/Лабы/temp_files$ diff -s file1 file3
Файлы file1 и file3 идентичны

#Ключ -y используется для вывода двух файлов в два столбца с указанием их различий. Более того ключ комбинируется с параметром --width, который указывает расстояние между столбцами для более читабельного вывода.
diff -y --width=50 file1 file2
Guy		      |	Danke
Hello			Hello
How are you	      |	guy
		      >	How Are
What			What
		      >	you

#Аргумент -i используется для игнорирования регистра букв (прописные, печатные). ps подразумевается то, что слова будут находиться на одном и том же номере строки в двух файлах.
diff -iy --width=50 file1 file2
Hello			Hello
Guy			guy
How are you	      |	Danke
		      >	How Are
What			What
		      >	you

#Для сравнения с перемешанными строками:
diff -iy --width=50 file1 file2
Guy		      <
Hello			Hello
How are you	      |	guy
		      >	Danke
		      >	How Are
What			What
		      >	you
#Ключ -w используется для игнорирования ВСЕХ пробелов в файлах. В примере ниже Howare == how Are.
diff -wyi --width=50 file1 file2
Guy		      <
Hello			Hello
Howare			How Are
  you			you
What			What
		      >	Danke
#Стоит немного вернуться назад и рассмотреть стандартный вывод команды без ключей:
diff  file1 file2
1d0
< Guy
3,4c2,3
< Howare
<   you
---
> How Are
> you
5a5
> Danke

#Здесь мы встречаем служебные метки, которые говорят, что надо делать с файлами (a — добавление, c — изменение и d — удаление).
#Слева пишется строка в первом файле, посередине команда, справа строка из второго файла.
#Первая строка должна быть удалена (1d0).
#То есть мы видим, что 3,4 строки должны быть изменены согласно строкам 2,3 из второго файла (3,4c2,3).
#В конце мы должны в 5 строку первого файла добавить 5 строку второго (5a5).
# > - Добавление, < - удаление строки.
#Однако читать это не очень комфортно, поэтому придумали ключ -u.

#Ключ -u используется для вывода унифицированного формата. С его помощью легче воспринимать что нужно удалить из первого файла, а что добавить.
diff -u file1 file2
--- file1	2022-04-21 19:45:27.180190408 +0300
+++ file2	2022-04-21 19:46:13.847994456 +0300
@@ -1,5 +1,5 @@
-Guy
 Hello
-Howare
-  you
+How Are
+you
 What
+Danke

#Ну, как я и говорил, команда схожа с Git в процессе решения конфликтов слияния, собственно для сравнения исходного кода эта команда подходит наилучшим образом.
#Однако вывод в консоль таких больших программ очень неудобен и вообще глаза сразу начинают бегать, поэтому рациональнее записать вывод в новый файл с исходным кодом и оттуда уже потихоньку вносить изменения в основной файл,
либо просто смотреть и сравнивать, это уже зависит от ваших потребностей. В определенных случаях, данный метод позволит целиком переносить функции которые были добавлены в файл без лишних заморочек.
#Однако почти во всех современных IDE есть такой же функционал.
#Но, на этом польза данного метода не заканчивается, здесь на выручку приходит команда patch, которая может любезно изменить нам файл и сделать из него второй передаваемый нами файлик. Но об этом чуть позже.
diff -up Segment.cpp segment1.cpp 
--- Segment.cpp	2022-04-03 23:19:23.000000000 +0300
+++ segment1.cpp	2022-03-30 12:25:08.000000000 +0300
@@ -1,43 +1,52 @@
-#include "../Segment.h"
-using namespace geometry;
+#include "../segment.h"
+#include "../vector.h"
+#include "../line.h"
 
-Segment::Segment() {
-	start = Point(0, 0);
-	end = Point(0, 0);
-}
-
-Segment::Segment(Point st, Point en) {
-  start.x_ = st.x_;
-  start.y_ = st.y_;
-  end.x_ = en.x_;
-  end.y_ = en.y_;
-}
-
-Segment& Segment::Move(const Vector &vector)  {
-  start.x_ += vector.en_x;
-  start.y_ += vector.en_y;
-  end.x_ += vector.en_x;
-  end.y_ += vector.en_y;
+namespace geometry {
+
+Segment::Segment(const Point &beg, const Point &end) : beg_(beg), end_(end) {
+}
+
+Segment &Segment::operator=(const Segment &segment) {
+  beg_ = segment.beg_;
+  end_ = segment.end_;
   return *this;
 }
 
-bool Segment::ContainsPoint(const Point &obj) const {
-  Vector fir(obj.x_ - start.x_, obj.y_ - start.y_);
-  Vector sec(end.x_ - obj.x_, end.y_ - obj.y_);
-  if (fir.en_x * sec.en_y - fir.en_y * sec.en_x == 0 && fir.en_x * sec.en_x + fir.en_y * sec.en_y >= 0) {
-	return true;
+Segment &Segment::Move(const Vector &vector) {
+  beg_ += vector;
+  end_ += vector;
+  return *this;
+}
+std::unique_ptr<IShape> Segment::Clone() const {
+  return std::make_unique<Segment>(beg_, end_);
+}
+bool Segment::ContainsPoint(const Point &point) const {
+  return point.CrossesSegment(*this);
+}
+bool Segment::CrossesSegment(const Segment &segment) const {
+  Line line1(beg_, end_);
+  Line line2(segment.beg_, segment.end_);
+  if (line1.CrossesSegment(segment) && line2.CrossesSegment(*this)) {
+    return std::min(segment.beg_.GetX(), segment.end_.GetX()) <= std::max(beg_.GetX(), end_.GetX()) &&
+           std::min(segment.beg_.GetY(), segment.end_.GetY()) <= std::max(beg_.GetY(), end_.GetY());
   }
   return false;
 }
+std::string Segment::ToString() const {
+  std::string ret = "Segment(";
+  ret += beg_.ToString();
+  ret += ", ";
+  ret += end_.ToString();
+  ret += ")";
+  return ret;
+}
 
-bool Segment::CrossesSegment(const Segment &) const {
-  return false;
+Point Segment::GetBeg() const {
+  return beg_;
 }
-std::unique_ptr<IShape> Segment::Clone() {
-  return std::unique_ptr<IShape>();
+Point Segment::GetEnd() const {
+  return end_;
 }
 
-
-
-
-
+}  // namespace geometry
rokivals@RoKi:~/Документы/Geometry/src$ diff -up Segment.cpp segment1.cpp > segment2.cpp

#Хотя можно и сразу затронуть patch. Суть этой команды в том, чтобы по тем самым служебным меткам (которые были выше) преобразовывать файл.
#То есть, мы вызываем изначально diff между двумя файлами (БЕЗ КЛЮЧЕЙ), дальше перенаправляем вывод в новый файл (имя.patch необязательно, но для понимания лучше так называть)
#Далее мы используем конструкцию patch исходный_файл -i файл с патчем -o новый_файл
#исходный файл - первый аргумент diff (file1), новый_файл - любой новый файл.
diff Point.cpp point.cpp > point.patch
patch Point.cpp -i point.patch -o Point2.cpp 
patching file Point2.cpp (read from Point.cpp)

#В таком случае получим нужный нам файл, ВАЖНО не использовать перенаправление в оригинальный файл (не писать patch file1 -i file.patch > file1).
#Также существуют контекстные патчи, создаваемые с помощью diff -c, по сути то же самое, что обычный diff, но работает с контекстом а не со строками.
#Применяется также, только в команде patch не надо указывать исходный файл.
#Грубо говоря, патч несёт в себе информацию о старом и новом файле одновременно, а не только те строки которые надо изменить.

diff -c Vector.cpp vector.cpp >vector.patch
rokivals@RoKi:~/Документы/Geometry/src$ patch -i vector.patch -o new_vector
patching file new_vector (read from Vector.cpp)

#Раз уж речь о патче, то поговорим о его ключах:
#--dry-run - ключ для применения патча без внесения его в файл (то есть вывод на стандартный поток вывода, чтобы посмотреть, как применяется патч).

rokivals@RoKi:~/Документы/Geometry/src$ diff -c Vector.cpp vector.cpp >vector.patch
rokivals@RoKi:~/Документы/Geometry/src$ patch --dry-run <vector.patch 
checking file Vector.cpp
#В примере выше на ввод подаётся контекстный патч, так можно и это очень даже хорошо работает.
#Есть ключ -b, который отвечает за бекап, ОЧЕНЬ ПОЛЕЗНО, ибо я работая с патчем уже сто раз пожалел о том, что не знал про этот ключ.
#Данный ключ создаёт ещё один оригинальный файл, который можно будет вернуть в случае чего.

#Есть ещё и ключ -R, который позволяет совершить откат патча, однако, если вы примените неработающий патч, то откат будет не таким уж простым и геморным, поэтому даже лезть туда не стоит 
и проще всегда использовать -b на всякий случай.

P.S. Важная деталь, которую я упустил, если опустить ключ -o, то будет изменён исходный файл, как мы изначально и хотели.
-----------------------------------GREP-------------------------------------------
#Данная утилита очень популярна и любима всеми линуксоводами, поскольку она помогает в поиске текста, строк и так далее по списку, более того,
#она как настоящий текстовый поиск поддерживает регулярки, шаблоны и так далее по списку. Ну и конечно же она незаменима в конвейерах.
#Ну и начнём с любимого - вывода интерфейсов подключений с grep по слову "inet".
ifconfig
enp0s3: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 10.0.2.15  netmask 255.255.255.0  broadcast 10.0.2.255
        inet6 fe80::c22d:9881:b4e9:8a26  prefixlen 64  scopeid 0x20<link>
        ether 08:00:27:ba:69:13  txqueuelen 1000  (Ethernet)
        RX packets 364910  bytes 334573579 (334.5 MB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 197270  bytes 32431355 (32.4 MB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536
        inet 127.0.0.1  netmask 255.0.0.0
        inet6 ::1  prefixlen 128  scopeid 0x10<host>
        loop  txqueuelen 1000  (Локальная петля (Loopback))
        RX packets 47590  bytes 4592151 (4.5 MB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 47590  bytes 4592151 (4.5 MB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

rokivals@RoKi:~/Документы/Geometry/src$ ifconfig | grep inet
        inet 10.0.2.15  netmask 255.255.255.0  broadcast 10.0.2.255
        inet6 fe80::c22d:9881:b4e9:8a26  prefixlen 64  scopeid 0x20<link>
        inet 127.0.0.1  netmask 255.0.0.0
        inet6 ::1  prefixlen 128  scopeid 0x10<host>

#Получим 4 строки, где как-либо присутсвует слово inet (как целое слово, так и будучи частью большего слова inet6).

#Пробежимся по ключам, коих очень много и они в большинстве своём все полезные.
#Ключ -b - показывает перед строкой ещё и номер символа (блока), с которого начинается нужное нам слово.
ifconfig | grep -b inet
61:        inet 10.0.2.15  netmask 255.255.255.0  broadcast 10.0.2.255
129:        inet6 fe80::c22d:9881:b4e9:8a26  prefixlen 64  scopeid 0x20<link>
535:        inet 127.0.0.1  netmask 255.0.0.0
577:        inet6 ::1  prefixlen 128  scopeid 0x10<host>

#Ключ -c подсчитывает кол-во вхождений нужного нам слова.
rokivals@RoKi:~/Документы/Geometry/src$ ifconfig | grep  -c  inet
4

#Когда мы не знаем, какие нам нужны буквы (заглавные или маленькие) для поиска файла или слова, мы используем ключ -i
ifconfig | grep  -i  INET
        inet 10.0.2.15  netmask 255.255.255.0  broadcast 10.0.2.255
        inet6 fe80::c22d:9881:b4e9:8a26  prefixlen 64  scopeid 0x20<link>
        inet 127.0.0.1  netmask 255.0.0.0
        inet6 ::1  prefixlen 128  scopeid 0x10<host>

#Помимо использования внутри конвейера, можно также искать слова или строки внутри файлов

grep -ic roki  ~/Документы/Информатика/Лабы/Лабораторная\ 20/lab20.txt 
15

grep -ic "мы не знаем"  ~/Документы/Информатика/Лабы/Лабораторная\ 20/lab20.txt 
1

#А вот и два примера с регулярками (RegEx), которые включают в себя поиск букв от а до я в первом случае и от а до д во втором.
#Понятно, что правила написания регулярок намного больше и ограничиваются не только диапазоном каких-то букв, но рассматривать их все в этой лабораторке - too much,
 поэтому просто приведу все правила написания регулярных выражений (метасимволы).
grep -ic "мы [а-я]"  ~/Документы/Информатика/Лабы/Лабораторная\ 20/lab20.txt 
15
grep -ic "мы [а-д]"  ~/Документы/Информатика/Лабы/Лабораторная\ 20/lab20.txt 
5

Правила RegEX:
    \ - с обратной косой черты начинаются буквенные спецсимволы, а также он используется если нужно использовать спецсимвол в виде какого-либо знака препинания (проще говоря - экранирование спецсимволов);
    ^ - указывает на начало строки;
    $ - указывает на конец строки;
    * - указывает, что предыдущий символ может повторяться 0 или больше раз;
    + - указывает, что предыдущий символ должен повторится больше один или больше раз;
    ? - предыдущий символ может встречаться ноль или один раз;
    {n} - указывает сколько раз (n) нужно повторить предыдущий символ;
    {N,n} - предыдущий символ может повторяться от N до n раз;
    . - любой символ кроме перевода строки;
    [az] - любой символ, указанный в скобках;
    х|у - символ x или символ y;
    [^az] - любой символ, кроме тех, что указаны в скобках;
    [a-z] - любой символ из указанного диапазона;
    [^a-z] - любой символ, которого нет в диапазоне;
    \b - обозначает границу слова с пробелом;
    \B - обозначает что символ должен быть внутри слова, например, ux совпадет с uxb или tuxedo, но не совпадет с Linux;
    \d - означает, что символ - цифра;
    \D - нецифровой символ;
    \n - символ перевода строки;
    \s - один из символов пробела, пробел, табуляция и так далее;
    \S - любой символ кроме пробела;
    \t - символ табуляции;
    \v - символ вертикальной табуляции;
    \w - любой буквенный символ, включая подчеркивание;
    \W - любой буквенный символ, кроме подчеркивания;
    \uXXX - символ Unicode.


#Ключ -n используется для указания строки, в которой находится нужный нам текст:
grep -bn "мы [а-д]"  ~/Документы/Информатика/Лабы/Лабораторная\ 20/lab20.txt 
371:19019:#Здесь мы встречаем служебные метки, которые говорят, что надо делать с файлами (a — добавление, c — изменение и d — удаление).
374:19480:#То есть мы видим, что 3,4 строки должны быть изменены согласно строкам 2,3 из второго файла (3,4c2,3).
375:19653:#В конце мы должны в 5 строку первого файла добавить 5 строку второго (5a5).
489:24670:#То есть, мы вызываем изначально diff между двумя файлами (БЕЗ КЛЮЧЕЙ), дальше перенаправляем вывод в новый файл (имя.patch необязательно, но для понимания лучше так называть)

#Заметьте, можно комбинировать ключ строки с ключом символа, может быть крайне полезно.
p.s. Да, я в grep использую свою же лабораторку, почему нет?)

#Ключ -v делает инверсию поиска - выдаёт всё то, что не содержит указанных слов.
echo "я тут
> как дела
> что делаешь
> Маяковский
> Высоцкий" | grep -iv "как"
я тут
что делаешь
Маяковский
Высоцкий

#Ключ -e используется для применения регулярных выражений, стоит сказать, что опред метасимволы grep скушает и без этого ключа, но порой можно получить не совсем то, что ожидали, поэтому лучше использовать его.
#На примерах ниже видно, что терминал и без этого ключа обрабатывает запрос с метасимволом '\w'.
 
grep -e "Ключ -\w"  ~/Документы/Информатика/Лабы/Лабораторная\ 20/lab20.txt 
#Ключ -b даёт нам информацию о самом различии (то есть что лежит в первом и втором файлах). В примере выше сложно понять, поскольку в file2 используется русский алфавит.
#Ключ -l даёт нам информацию о всех позициях где есть различия между файлами (с указанием значений байтов):
#Ключ -о позволяет выводить результат в файл, поэтому просто пишем 
#Ключ -q позволяет использовать diff просто для понимания, различны ли файлы. По сути, работает как cmp, но без вывода информации о различиях.
#Ключ -s выводит информацию о том идентичны ли файлы (по умолчанию данная информация не выводится).
#Ключ -y используется для вывода двух файлов в два столбца с указанием их различий. Более того ключ комбинируется с параметром --width, который указывает расстояние между столбцами для более читабельного вывода.
#Ключ -w используется для игнорирования ВСЕХ пробелов в файлах. В примере ниже Howare == how Are.
#Ключ -u используется для вывода унифицированного формата. С его помощью легче воспринимать что нужно удалить из первого файла, а что добавить.
#Ключ -b - показывает перед строкой ещё и номер символа (блока), с которого начинается нужное нам слово.
#Ключ -c подсчитывает кол-во вхождений нужного нам слова.
#Ключ -n используется для указания строки, в которой находится нужный нам текст:
#Ключ -v делает инверсию поиска - выдаёт всё то, что не содержит указанных слов.


grep "Ключ -\w"  ~/Документы/Информатика/Лабы/Лабораторная\ 20/lab20.txt 
#Ключ -b даёт нам информацию о самом различии (то есть что лежит в первом и втором файлах). В примере выше сложно понять, поскольку в file2 используется русский алфавит.
#Ключ -l даёт нам информацию о всех позициях где есть различия между файлами (с указанием значений байтов):
#Ключ -о позволяет выводить результат в файл, поэтому просто пишем 
#Ключ -q позволяет использовать diff просто для понимания, различны ли файлы. По сути, работает как cmp, но без вывода информации о различиях.
#Ключ -s выводит информацию о том идентичны ли файлы (по умолчанию данная информация не выводится).
#Ключ -y используется для вывода двух файлов в два столбца с указанием их различий. Более того ключ комбинируется с параметром --width, который указывает расстояние между столбцами для более читабельного вывода.
#Ключ -w используется для игнорирования ВСЕХ пробелов в файлах. В примере ниже Howare == how Are.
#Ключ -u используется для вывода унифицированного формата. С его помощью легче воспринимать что нужно удалить из первого файла, а что добавить.
#Ключ -b - показывает перед строкой ещё и номер символа (блока), с которого начинается нужное нам слово.
#Ключ -c подсчитывает кол-во вхождений нужного нам слова.
#Ключ -n используется для указания строки, в которой находится нужный нам текст:
#Ключ -v делает инверсию поиска - выдаёт всё то, что не содержит указанных слов.

#Существует ещё 3 ключа связанных с выводом строк, которые позволяют выводить n строк до/после/с двух сторон от найденной строки
#-An/-Bn/-Cn соотвественно, где n - кол-во строк.
Специально выделю текст "!", чтобы не теряться с остальной лабораторкой.

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
grep -iA5 "мы [а-г]"  ~/Документы/Информатика/Лабы/Лабораторная\ 20/lab20.txt 
#Мы видим, что команда находит первое отличие между двумя файлами и указывает на то, в какой строке это происходит

rokivals@RoKi:~/Документы/Информатика/Лабы/temp_files$ cmp -b file1 file2
file1 file2 различаются: байт 6, строка 1 равен  40    12 ^J

#Ключ -b даёт нам информацию о самом различии (то есть что лежит в первом и втором файлах). В примере выше сложно понять, поскольку в file2 используется русский алфавит.
--
#Здесь мы встречаем служебные метки, которые говорят, что надо делать с файлами (a — добавление, c — изменение и d — удаление).
#Слева пишется строка в первом файле, посередине команда, справа строка из второго файла.
#Первая строка должна быть удалена (1d0).
#То есть мы видим, что 3,4 строки должны быть изменены согласно строкам 2,3 из второго файла (3,4c2,3).
#В конце мы должны в 5 строку первого файла добавить 5 строку второго (5a5).
# > - Добавление, < - удаление строки.
#Однако читать это не очень комфортно, поэтому придумали ключ -u.

#Ключ -u используется для вывода унифицированного формата. С его помощью легче воспринимать что нужно удалить из первого файла, а что добавить.
--
#То есть, мы вызываем изначально diff между двумя файлами (БЕЗ КЛЮЧЕЙ), дальше перенаправляем вывод в новый файл (имя.patch необязательно, но для понимания лучше так называть)
#Далее мы используем конструкцию patch исходный_файл -i файл с патчем -o новый_файл
#исходный файл - первый аргумент diff (file1), новый_файл - любой новый файл.
diff Point.cpp point.cpp > point.patch
patch Point.cpp -i point.patch -o Point2.cpp 
patching file Point2.cpp (read from Point.cpp)
--
371:19019:#Здесь мы встречаем служебные метки, которые говорят, что надо делать с файлами (a — добавление, c — изменение и d — удаление).
374:19480:#То есть мы видим, что 3,4 строки должны быть изменены согласно строкам 2,3 из второго файла (3,4c2,3).
375:19653:#В конце мы должны в 5 строку первого файла добавить 5 строку второго (5a5).
489:24670:#То есть, мы вызываем изначально diff между двумя файлами (БЕЗ КЛЮЧЕЙ), дальше перенаправляем вывод в новый файл (имя.patch необязательно, но для понимания лучше так называть)

#Заметьте, можно комбинировать ключ строки с ключом символа, может быть крайне полезно.
p.s. Да, я в grep использую свою же лабораторку, почему нет?)

#Ключ -v делает инверсию поиска - выдаёт всё то, что не содержит указанных слов.
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


Есть ещё и ключ -w, который ищет слово как отдельное (то есть исключает вхождения в другое слово)
# Для сравнения наглядно пример:

Ввод: echo "Пушкин
Есенин
Гагарин
Маяковский
Маяк
Сплин" | grep -A3 "Маяк"

Вывод:
Маяковский
Маяк
Сплин

Ввод: echo "Пушкин
Есенин
Гагарин
Маяковский
Маяк
Сплин" | grep -wA3 "Маяк"

Вывод:
Маяк
Сплин

#В первом примере слово маяк является частью фамилии Маяковского, поэтому она была первой найдено с помощью команды grep и только после будет найдено само слово "Маяк".
#Во втором же примере, мы сразу получаем название песни Сплин и саму группу. (Маяк - песня Сплин по мотивам стиха Маяковского)

#Вот и пример работы ключа -Cn
echo "Пушкин
Есенин
Гагарин
Маяковский
Маяк
Сплин" | grep -C2 "Маяк"

Есенин
Гагарин
Маяковский
Маяк

#Также самый последний и важный ключик, который есть у многих команд это -r (рекурсивный поиск по файлам), то есть мы передаём грепу директорию с этим ключом и греп проходит по всем файлам этой директории
и ищет в них нужные нам строки.

grep -wcr "user" smartgit/

smartgit/lib/org.eclipse.swt.gtk.linux.aarch64.jar:24
smartgit/lib/format-patch.sh:0
smartgit/lib/jgit.jar:23
smartgit/lib/sqljet.jar:0
smartgit/lib/flexmark-ext-gfm-issues.jar:0
smartgit/lib/flexmark-ext-autolink.jar:0
smartgit/lib/flexmark.jar:0
smartgit/lib/jzlib-1.1.3.jar:0
smartgit/lib/eddsa-0.3.0.jar:0
smartgit/lib/irebase.sh:0
smartgit/lib/svnkit.jar:31
smartgit/lib/slf4j-jdk14-1.7.25.jar:0
smartgit/lib/jna-5.8.0.jar:0
smartgit/lib/org.eclipse.swt.gtk.linux.x86_64.jar:24
smartgit/lib/askpass.sh:0
smartgit/lib/sequence-library.jar:0
smartgit/lib/ssh.sh:0
smartgit/lib/bootloader.jar:3
smartgit/lib/smartgit.jar:139
smartgit/lib/antlr-runtime-4.7.2.jar:0
smartgit/lib/jna-platform-5.8.0.jar:0
smartgit/lib/flexmark-ext-gfm-strikethrough.jar:0
smartgit/lib/smartssh.sh:0
smartgit/lib/bcpkix-jdk15on-160.jar:0
smartgit/lib/ff-merge.sh:0
smartgit/lib/trilead.jar:0
smartgit/lib/jopt-simple-3.2.jar:0
smartgit/lib/flexmark-util.jar:0
smartgit/lib/lz4-1.3.0.jar:0
smartgit/lib/bootloader-config.jar:0
smartgit/lib/jmyspell-core.jar:0
smartgit/lib/snakeyaml.jar:0
smartgit/lib/flexmark-ext-gfm-users.jar:0
smartgit/lib/slf4j-api-1.7.25.jar:0
smartgit/lib/autolink-0.6.0.jar:0
smartgit/lib/javaewah.jar:0
smartgit/lib/credentials.sh:0
smartgit/lib/json_simple-1.1.jar:0
smartgit/lib/bcprov-jdk15on-160.jar:0
smartgit/lib/sshj.jar:0
smartgit/lib/jsch.jar:0
smartgit/license.html:9
smartgit/checksums:0


P.S. На самом деле вывод намного больше, просто потому что.
find smartgit/ | wc
    628     628   25515

#Ключ -l позволяет получить на вывод просто название файла, в котором содержится нужная нам строка

grep -wlr "user" smartgit/
smartgit/lib/org.eclipse.swt.gtk.linux.aarch64.jar
smartgit/lib/jgit.jar
smartgit/lib/svnkit.jar
smartgit/lib/org.eclipse.swt.gtk.linux.x86_64.jar
smartgit/lib/bootloader.jar
smartgit/lib/smartgit.jar
smartgit/license.html
smartgit/dictionaries/en_US.dic
smartgit/licenses/CHRONICLE-LICENSE
smartgit/licenses/JNA-LICENSE
smartgit/jre/lib/modules
smartgit/jre/lib/libjdwp.so
smartgit/jre/lib/server/libjvm.so
smartgit/jre/lib/libjava.so
smartgit/jre/conf/management/management.properties
smartgit/jre/conf/management/jmxremote.password.template
smartgit/jre/conf/logging.properties
smartgit/jre/conf/net.properties
smartgit/jre/conf/security/java.security
smartgit/jre/legal/java.security.jgss/LICENSE
smartgit/jre/legal/java.instrument/LICENSE
smartgit/jre/legal/java.xml/LICENSE
smartgit/jre/legal/java.management.rmi/LICENSE
smartgit/jre/legal/java.logging/LICENSE
smartgit/jre/legal/java.base/LICENSE
smartgit/jre/legal/java.base/public_suffix.md
smartgit/jre/legal/jdk.management/LICENSE
smartgit/jre/legal/jdk.crypto.ec/ecc.md
smartgit/jre/legal/jdk.crypto.ec/LICENSE
smartgit/jre/legal/java.naming/LICENSE
smartgit/jre/legal/java.management/LICEN
----------------------------------JOIN-------------------------------------------
#На очереди команда, позволяющая соединять два файла построчно по наличию общего поля.
#То есть, в каждой строке первого файла и второго есть опред поле, которое совпадает, исходя из него строки будут объединяться в одну.
#Это прекрасный инструмент для прикладных задач, особенно когда речь идёт о каких-либо чётко структурированных данных, разбитых на несколько файлов и вы хотите их совместить.

#По умолчанию общим полем считается первое (поля - слова разделённые пробелом).
===file1===
1 Adore Varian avarian0@newyorker.com Female 192.57.150.231
2 Nancee Merrell nmerrell1@ted.com Female 22.198.121.181
3 Herta Friett hfriett2@dagondesign.com Female 33.167.32.89
4 Torie Venmore tvenmore3@gmpg.org Female 251.9.204.115
5 Deni Sealeaf dsealeaf4@nps.gov Female 210.53.81.212
6 Fidel Bezley fbezley5@lulu.com Male 72.173.218.75
7 Ulrikaumeko Standen ustanden6@geocities.jp Female 4.204.0.237
8 Odell Jursch ojursch7@utexas.edu Male 1.138.85.117

===file2===
1 Varian avarian0@newyorker.com Female Western New York $535,304.73
2 Merrell nmerrell1@ted.com Female Finger Lakes $309,033.10
3 Friett hfriett2@dagondesign.com Female Southern Tier $461,664.44
4 Venmore tvenmore3@gmpg.org Female Central New York $175,818.02
5 Sealeaf dsealeaf4@nps.gov Female North Country $126,690.15
6 Bezley fbezley5@lulu.com Male Mohawk Valley $366,733.78
7 Standen ustanden6@geocities.jp Female Capital District $674,634.93
8 Jursch ojursch7@utexas.edu Male Hudson Valley $663,821.09

#Вот пример работы слияния файлов, он принимает базово за общее поле - первое слово (цифры идущие по возрастанию) и печатает сначал первый файл, следом второй без повторения общего поля.
join file1 file2
1 Adore Varian avarian0@newyorker.com Female 192.57.150.231 Varian avarian0@newyorker.com Female Western New York $535,304.73
2 Nancee Merrell nmerrell1@ted.com Female 22.198.121.181 Merrell nmerrell1@ted.com Female Finger Lakes $309,033.10
3 Herta Friett hfriett2@dagondesign.com Female 33.167.32.89 Friett hfriett2@dagondesign.com Female Southern Tier $461,664.44
4 Torie Venmore tvenmore3@gmpg.org Female 251.9.204.115 Venmore tvenmore3@gmpg.org Female Central New York $175,818.02
5 Deni Sealeaf dsealeaf4@nps.gov Female 210.53.81.212 Sealeaf dsealeaf4@nps.gov Female North Country $126,690.15
6 Fidel Bezley fbezley5@lulu.com Male 72.173.218.75 Bezley fbezley5@lulu.com Male Mohawk Valley $366,733.78
7 Ulrikaumeko Standen ustanden6@geocities.jp Female 4.204.0.237 Standen ustanden6@geocities.jp Female Capital District $674,634.93
8 Odell Jursch ojursch7@utexas.edu Male 1.138.85.117 Jursch ojursch7@utexas.edu Male Hudson Valley $663,821.09

#Здесь важно чтобы общее поле было отсортировано, то есть, чтобы в первой и во втором файлах общее поле было отсортировано в противном случае будет выведена ошибка по типу:
join file1 file2
1 Adore Varian avarian0@newyorker.com Female 192.57.150.231 Varian avarian0@newyorker.com Female Western New York $535,304.73
2 Nancee Merrell nmerrell1@ted.com Female 22.198.121.181 Merrell nmerrell1@ted.com Female Finger Lakes $309,033.10
3 Herta Friett hfriett2@dagondesign.com Female 33.167.32.89 Friett hfriett2@dagondesign.com Female Southern Tier $461,664.44
4 Torie Venmore tvenmore3@gmpg.org Female 251.9.204.115 Venmore tvenmore3@gmpg.org Female Central New York $175,818.02
join: file2:6: без сортировки: 5 Bezley fbezley5@lulu.com Male Mohawk Valley $366,733.78
6 Fidel Bezley fbezley5@lulu.com Male 72.173.218.75 Sealeaf dsealeaf4@nps.gov Female North Country $126,690.15
7 Ulrikaumeko Standen ustanden6@geocities.jp Female 4.204.0.237 Standen ustanden6@geocities.jp Female Capital District $674,634.93
8 Odell Jursch ojursch7@utexas.edu Male 1.138.85.117 Jursch ojursch7@utexas.edu Male Hudson Valley $663,821.09

file2 в этот момент выглядел так:
1 Varian avarian0@newyorker.com Female Western New York $535,304.73
2 Merrell nmerrell1@ted.com Female Finger Lakes $309,033.10
3 Friett hfriett2@dagondesign.com Female Southern Tier $461,664.44
4 Venmore tvenmore3@gmpg.org Female Central New York $175,818.02
6 Sealeaf dsealeaf4@nps.gov Female North Country $126,690.15
5 Bezley fbezley5@lulu.com Male Mohawk Valley $366,733.78
7 Standen ustanden6@geocities.jp Female Capital District $674,634.93
8 Jursch ojursch7@utexas.edu Male Hudson Valley $663,821.09

#Для избежания проблем с сортировкой, можно использовать --check-order, который мы уже использовали ранее для comm.

#Что же делать если у нас разнится кол-во строк в файлах? По умолчанию, join выведет всевозможные строки, которые сможет объединить (предварительно мы удалили последнюю строку из file2).
join file1 file2
1 Adore Varian avarian0@newyorker.com Female 192.57.150.231 Varian avarian0@newyorker.com Female Western New York $535,304.73
2 Nancee Merrell nmerrell1@ted.com Female 22.198.121.181 Merrell nmerrell1@ted.com Female Finger Lakes $309,033.10
3 Herta Friett hfriett2@dagondesign.com Female 33.167.32.89 Friett hfriett2@dagondesign.com Female Southern Tier $461,664.44
4 Torie Venmore tvenmore3@gmpg.org Female 251.9.204.115 Venmore tvenmore3@gmpg.org Female Central New York $175,818.02
5 Deni Sealeaf dsealeaf4@nps.gov Female 210.53.81.212 Sealeaf dsealeaf4@nps.gov Female North Country $126,690.15
6 Fidel Bezley fbezley5@lulu.com Male 72.173.218.75 Bezley fbezley5@lulu.com Male Mohawk Valley $366,733.78
7 Ulrikaumeko Standen ustanden6@geocities.jp Female 4.204.0.237 Standen ustanden6@geocities.jp Female Capital District $674,634.93

#Однако с помощью ключа -a (1 / 2) мы можем попросить команду выводить все строки, которые он может соединить, а для тех у которых нет пары, выводить строку только из одного файла (1 или 2).
join -a 1 file1 file2
1 Adore Varian avarian0@newyorker.com Female 192.57.150.231 Varian avarian0@newyorker.com Female Western New York $535,304.73
2 Nancee Merrell nmerrell1@ted.com Female 22.198.121.181 Merrell nmerrell1@ted.com Female Finger Lakes $309,033.10
3 Herta Friett hfriett2@dagondesign.com Female 33.167.32.89 Friett hfriett2@dagondesign.com Female Southern Tier $461,664.44
4 Torie Venmore tvenmore3@gmpg.org Female 251.9.204.115 Venmore tvenmore3@gmpg.org Female Central New York $175,818.02
5 Deni Sealeaf dsealeaf4@nps.gov Female 210.53.81.212 Sealeaf dsealeaf4@nps.gov Female North Country $126,690.15
6 Fidel Bezley fbezley5@lulu.com Male 72.173.218.75 Bezley fbezley5@lulu.com Male Mohawk Valley $366,733.78
7 Ulrikaumeko Standen ustanden6@geocities.jp Female 4.204.0.237 Standen ustanden6@geocities.jp Female Capital District $674,634.93
8 Odell Jursch ojursch7@utexas.edu Male 1.138.85.117

#Чтобы увидеть строки, для которых нет совпадений используем ключ -v (1 / 2), который выведет все строки выбранного файла, для которых нет пары во втором файле.

join -v 1 file1 file2
8 Odell Jursch ojursch7@utexas.edu Male 1.138.85.117

join -v 2 file1 file2

# Проще показать на примере, в первом случае у второго файла не нашлось строки в пару к 8-ой строке первого файла.
# Во втором же примере, у первого файла есть все строки, которые можно присоединить ко второму.
# Ну и самое главное это изменить общее поле. Делается это с помощью ключей -1 и -2 для первого и второго файла соответственно.
# Попробуем объединить файлы по email, логично было бы их отсортировать, но как показывает практика, join прекрасно отработает и без этого: 
join -1 3 -2 2 --check-order file1 file2
avarian0@newyorker.com Adore Varian Female 192.57.150.231 Varian Female Western New York $535,304.73
join: file1:3: без сортировки: Herta Friett hfriett2@dagondesign.com Female 33.167.32.89

rokivals@RoKi:~/Документы/Информатика/Лабы/temp_files$ join -1 3 -2 2 file1 file2
avarian0@newyorker.com Adore Varian Female 192.57.150.231 Varian Female Western New York $535,304.73
nmerrell1@ted.com Nancee Merrell Female 22.198.121.181 Merrell Female Finger Lakes $309,033.10
hfriett2@dagondesign.com Herta Friett Female 33.167.32.89 Friett Female Southern Tier $461,664.44
tvenmore3@gmpg.org Torie Venmore Female 251.9.204.115 Venmore Female Central New York $175,818.02
dsealeaf4@nps.gov Deni Sealeaf Female 210.53.81.212 Sealeaf Female North Country $126,690.15
fbezley5@lulu.com Fidel Bezley Male 72.173.218.75 Bezley Male Mohawk Valley $366,733.78
ustanden6@geocities.jp Ulrikaumeko Standen Female 4.204.0.237 Standen Female Capital District $674,634.93

#Для использования другого разделителя между блоками используется ключ -t.
Пример:
join -t- -1 3 -2 2 file3 file4
avarian0@newyorker.com-Adore-Varian-Female-192.57.150.231-Varian-Female-Western New York-$535,304.73
nmerrell1@ted.com-Nancee-Merrell-Female-22.198.121.181-Merrell-Female-Finger Lakes-$309,033.10

Ключ -i игнорирует регистр, пример работы уже показывался много раз выше.
----------------------------------SORT-------------------------------------------
#Как и говорил, мы вернёмся к сортировке ещё, но позже. Данная утилита используется для сортировки строк внутри файлов по лексикографическому порядку.
#Пара правил, которые стоит помнить при сортировке:
1) Строки, начинающиеся с цифр идут раньше строк, начинающихся с букв. (Объясняется тем, что цифры в таблице символов идут раньше любого алфавита).
2) Строки выводятся в алфавитном порядке.
3) Строки начинающиеся со строчных букв выводятся раньше строк, начинающихся с тех же заглавных букв.
P.S. Если вспомнить те же регулярки, то если мы хотим захватить одновременно и строчные и заглавные буквы, тогда диапазоны начинаются с маленькой и заканчиваются большой, 
 (например [a-Z], потому что маленькие буквы идут первее заглавных).
Хотя в таблице ascii наоборот...

===file3===
Художник
Онегин
Зайцев
Шипулин
Сплин
БИ-2
7 цифр
Du Hast
Du hast
БИ - 2
Маяковский
Маяк

#Обратим внимание на результат ниже. Пробел воспринимается по алфавиту раньше, нежели любой другой символ, паритет строчных букв над заглавными действует на протяжении всей строки.
sort file3
7 цифр
Du hast
Du Hast
БИ - 2
БИ-2
Зайцев
Маяк
Маяковский
Онегин
Сплин
Художник
Шипулин

#Ключ -r --reverse позволяет вывести сортировку в обратном порядке (с конца).

sort -r file3
Шипулин
Художник
Сплин
Онегин
Маяковский
Маяк
Зайцев
БИ-2
БИ - 2
Du Hast
Du hast
7 цифр

#Сортировать можно по разным полям, как у прошлой функции поля разделяются пробелами, а поле сортировки по умолчанию - первое.

===file4===
Художник 1
Онегин 2
Зайцев 4
Шипулин 5
Сплин 6
БИ-2 3
Du Hast 10
Du hast 0 
БИ2 11
Маяковский 9
Маяк 7

sort -k 2 file4
Художник 1
БИ2 11
Онегин 2
БИ-2 3
Зайцев 4
Шипулин 5
Сплин 6
Маяк 7
Маяковский 9
Du hast 0 
Du Hast 10

#Сортировка отработала абсолютно правильно, поскольку в последних двух полях вторым полем выступает hast, а не цифра. Насчёт 1 и 11, сорт воспринимает числа, как строки, поэтому тоже всё верно.
===file4===
VAG
Volkswagen
Toyota
Rolls-Royce
BMW
Audi
Lancia
Renault
Ford
Chevrolet
Honda
McLaren
Ferrari
Porsche
Lada
UAZ
Volkswagen
Seat
Skoda
MAN
Ducati
Bugatti
BMW
Mercedes-Benz

#Ключ -u удаляет дубли в файле.

sort -u file4
Audi
BMW
Bugatti
Chevrolet
Ducati
Ferrari
Ford
Honda
Lada
Lancia
MAN
McLaren
Mercedes-Benz
Porsche
Renault
Rolls-Royce
Seat
Skoda
Toyota
UAZ
VAG
Volkswagen

#Ключ -c проверяет отсортирован ли файл, если нет, то выводит строки нарушающие сортировку.
sort -c file4
sort: file4:3: неправильный порядок: Toyota

#Ключ -h --human-numeric-sort позволяет воспринимать числа передаваемые в поле, как числа, то есть, в привычном для нас виде. Вот два примера для сравнения.

sort -k 2  file3
Маяковский 0
Зайцев 100
Художник 2
Онегин 3
Шипулин 4
Сплин 5
БИ-2 6
Маяк 7

rokivals@RoKi:~/Документы/Информатика/Лабы/temp_files$ sort -k 2 -h file3
Маяковский 0
Художник 2
Онегин 3
Шипулин 4
Сплин 5
БИ-2 6
Маяк 7
Зайцев 100

#С добавлением ключа -h, который работает также как и -n. 100 сразу же стало последним, как и должно быть при сравнении чисел.
#Ключ -R делает рандомную сортировку, тут мне кажется нечего пояснять.
#Ключ -b игнорирует пробелы в начале (аналог .strip() из питона).
#Ключ -f для игнорирования регистра.
#Ключ -i для игнорирования непечатных символов (это символы которые обычно получаем после неудачной кодировки файла). Например: @&^ и так далее...
#Вот два примера для сравнения.
sort file3
БИ-2 6
Зайцев 100
Маяк ^@7
Маяковский 0
Онегин 3
Сплин 5
Художник 2
Шипулин 4

rokivals@RoKi:~/Документы/Информатика/Лабы/temp_files$ sort -i file3
Маяковский 0
Зайцев 100
Художник 2
БИ-2 6
Онегин 3
Шипулин 4
Сплин 5
Маяк ^@7


#Есть ещё ключ -g, который советуют избегать в документации, он работает уже не просто с числами, а с плавающими точками, то есть с цифрами типа float. А как мы прекрасно уже знаем, там очень много можно поймать непредвиденных ошибок.
А ещё с этим ключом команда работает в несколько раз медленее.

#Ну и если пригодится сортировать данные по месяцам, то используйте ключ -M.

P.S. Примеры для этого приводить надеюсь необязательно, поскольку вроде всё понятно и без них.
----------------------------------TAIL-------------------------------------------
#Часто приходится знать что находится в конце файла. Для этого и существует команда tail, позволяющая
#вывести опред кол-во строк с конца файла.
===file4===
VAG
Volkswagen
Toyota
Rolls-Royce
BMW
Audi
Lancia
Renault
Ford
Chevrolet
Honda
McLaren
Ferrari
Porsche
Lada
UAZ
Volkswagen
Seat
Skoda
MAN
Ducati
Bugatti
BMW
Mercedes-Benz

#По умолчанию, команда выводит последние 10 строк файла.
tail file4
Lada
UAZ
Volkswagen
Seat
Skoda
MAN
Ducati
Bugatti
BMW
Mercedes-Benz

#Ключом -c можно указать кол-во байт выводимых с конца, а ключом -n кол-во строк.
tail -n 5 file4
MAN
Ducati
Bugatti
BMW
Mercedes-Benz

tail -c 100 file4
t
Honda
McLaren
Ferrari
Porsche
Lada
UAZ
Volkswagen
Seat
Skoda
MAN
Ducati
Bugatti
BMW
Mercedes-Benz

#Также с ключом -c можно использовать обозначения информационного объёма (аналогично с командой DD).

tail -c 1kB 1984 
�, такая попытка была бы невообразимо опасной. За секунду они успели обменяться двусмысленным взглядом — вот и все. Но даже это было памятным событием для человека, чья жизнь проходит под замком одиночества.

Уинстон встряхнулся, сел прямо. Он рыгнул. Джин бунтовал в желудке.

Глаза его снова сфокусировались на странице. Оказалось, что, пока он был занят беспомощными размышлениями, рука продолжала писать автоматически. Но не судорожные каракули, как вначале. Перо сладострастно скользило по глянцевой бумаге, крупными печатными буквами выводя:


#Ключ -v позволяет вывести информацию о файле.

tail -vc 100 1984 
==> 1984 <==
� глянцевой бумаге, крупными печатными буквами выводя:

#Ключ -f позволяет отслеживать изменения в файле в реальном времени (прикладное применение в логах). !!! Не сработает при изменении файла через текстовый редактор !!!
#Продемонстрировать данный пример крайне сложно, поэтому просто поверьте на слово, я проверил, с помощью второй консоли оно работает.
----------------------------------TEE--------------------------------------------
#Мы прекрасно знаем о том, что вывод из команды можно перенаправить в какой либо файл, но что делать, если нам нужно записать вывод в несколько файлов одновременно,
 тогда нам на помощь придёт команда tee. Она принимает на вход вывод какой-либо команды и записывает его в указанные нами файлы.

#Ключ -a используется для того, чтобы записать результат в конец уже существующего файла. (Без этого ключа файл будет перезаписан)

echo 2002 | tee file3
2002
rokivals@RoKi:~/Документы/Информатика/Лабы/temp_files$ cat file3
2002
rokivals@RoKi:~/Документы/Информатика/Лабы/temp_files$ echo 2002 | tee -a file3
2002
rokivals@RoKi:~/Документы/Информатика/Лабы/temp_files$ cat file3
2002
2002
#Можно заметить, что после выполнения команд, результат также посылается и в поток стандартного вывода => что его можно прокинуть дальше в конвейер, например в команду wc или куда нам понадобится.
#Если же мы хотим убрать вывод из потока, то просто перенаправим поток вывода в dev/null.

echo 2002 | tee -a file3 >/dev/null
rokivals@RoKi:~/Документы/Информатика/Лабы/temp_files$ cat file3
2002
2002
2002

#Ну и самое главное, что можно сделать с помощью tee - направить вывод в несколько файлов.

ls -la | tee file3 file5 >/dev/null
rokivals@RoKi:~/Документы/Информатика/Лабы/temp_files$ cat file3 file5
итого 72
drwxrwxr-x 2 rokivals rokivals  4096 апр 23 00:41 .
drwxrwxr-x 4 rokivals rokivals  4096 апр 21 17:09 ..
-rw-rw-r-- 1 rokivals rokivals 49282 апр 23 00:21 1984
-rw-rw-r-- 1 rokivals rokivals   440 апр 23 00:25 file1
-rw-rw-r-- 1 rokivals rokivals   434 апр 22 00:04 file2
-rw-rw-r-- 1 rokivals rokivals     0 апр 23 00:41 file3
-rw-rw-r-- 1 rokivals rokivals   171 апр 22 00:54 file4
-rw-rw-r-- 1 rokivals rokivals     0 апр 23 00:41 file5
итого 72
drwxrwxr-x 2 rokivals rokivals  4096 апр 23 00:41 .
drwxrwxr-x 4 rokivals rokivals  4096 апр 21 17:09 ..
-rw-rw-r-- 1 rokivals rokivals 49282 апр 23 00:21 1984
-rw-rw-r-- 1 rokivals rokivals   440 апр 23 00:25 file1
-rw-rw-r-- 1 rokivals rokivals   434 апр 22 00:04 file2
-rw-rw-r-- 1 rokivals rokivals     0 апр 23 00:41 file3
-rw-rw-r-- 1 rokivals rokivals   171 апр 22 00:54 file4
-rw-rw-r-- 1 rokivals rokivals     0 апр 23 00:41 file5
-----------------------------------TR---------------------------------------------
#Очень сильный инструмент для обработки текста, а точнее удаления замены и изменения этого самого текста.
#По умолчанию команда заменяет все заданные символы в первом аргументе символами из второго.
#Пример работы по умолчанию показан ниже (на ввод передаём файл).
tr Vol VAG <file4
VAG
VAGkswagen
TAyAta
RAGGs-RAyce
BMW
Audi
Lancia
RenauGt
FArd
ChevrAGet
HAnda
McLaren
Ferrari
PArsche
Lada
UAZ
VAGkswagen
Seat
SkAda
MAN
Ducati
Bugatti
BMW
Mercedes-Benz

#Также можно удалять строки, для этого используем ключ -d

tr -d "Vol" <file4
AG
kswagen
Tyta
Rs-Ryce
BMW
Audi
Lancia
Renaut
Frd
Chevret
Hnda
McLaren
Ferrari
Prsche
Lada
UAZ
kswagen
Seat
Skda
MAN
Ducati
Bugatti
BMW

#Вы можете заметить, что команда работает именно с НАБОРОМ значений, а не конкретно со строкой.
#Всё потому что аргументы передаются, как символьные строки. У них есть свои опции, по которым они составляются.
#С помощью -s можно уплотнить повторяющиеся буквы.
#Данная команда позволяет убрать повторения больших или маленьких букв (в оригинале первая строка VAAAAAGGGGGvaaag).
tr -s [:upper:][:lower:] <file4
VAGvag
Volkswagen
Toyota

#[:upper:] - одна из опций так называемых символьных строк.

#Ключ -c указывает на то, что надо обработать все символы НЕВОШЕДШИЕ в набор. (Здесь все заглавные буквы превратились в пробелы. Переносы строк тоже куда-то магически сбежали.
tr -c [:lower:] ' '  <file4
          vaaaaaaaaaaag  olkswagen  oyota  olls  oyce      udi  ancia  enault  ord  hevrolet  onda  c aren  errari  orsche  ada      olkswagen  eat  koda      ucati  ugatti      ercedes  enz 

-----------------------------------UNIQ-------------------------------------------
#Задача данной команды максимально проста - находить одинаковые строки в массивах текста.
#Далее уже в зависимости от указанных ключей и наших пожеланий, данная команда будет либо убирать эти повторяющиеся строки, либо выводить только их и так далее тому подобное.
#Однако у данной команды есть один важный подвох... Она сравнивает только соседние строки (поэтому, если между повторяющимися строками будет ещё одна, она их даже не заметит).
#Один из вариантов исправления - отсортировать слова перед передачей, либо использовать Питон.)

echo -e Лара\\nСаня\\nЛара\\nЛара | uniq
Лара
Саня
Лара
#Тут мы видим, что Лары через одну строчку остаются, а соседние превращаются в одну копию. То есть, uniq без ключей просто сводит повторы строк к одному значению.
#Из ключей есть интересный ключ -c который выводит количество повторов (того или иного слова)
echo "Лара
Лара
Лара" | uniq -c
      3 Лара


===file1===
Слава
Слава
Кира
Ира
Кира
Ирина
Вячеслав
Ярослав
Савелий

#Ключ -D выводит только повторяющиеся строки (в том количестве в котором они повторяются)
uniq -D <file1
Слава
Слава

#Ключ -d делает то же самое, что и -D, но в более ожидаемом понимании (он выводит повторяющуюся строку единожды).


#Ключ -u выводит строки, у которых нет повторов.
uniq -u <file1
Кира
Ира
Кира
Ирина
Вячеслав
Ярослав
Савелий
-----------------------------------OD-------------------------------------------
#Данная команда поможет нам представить файл в восьмеричном виде. Может быть полезна в ситуациях с нечитаемым для человека содержимым файла.
od   file1
0000000 120720 135720 130320 131320 130320 150012 150241 150273
0000020 150260 150262 005260 115320 134320 100321 130320 150012
0000040 150630 150200 005260 115320 134320 100321 130320 150012
0000060 150630 150200 150270 150275 005260 111320 107721 103721
0000100 132720 100721 135720 130320 131320 150012 150657 150200
0000120 150676 150201 150273 150260 005262 120720 130320 131320
0000140 132720 135720 134320 134720 005012
0000152

#По умолчанию мы получаем на вывод просто двухбайтовое 8-ричное представление.


#Ключ -A позволяет выводить информацию о порядке первого элемента в строке (самый первый столбец). Ключ имеет 4 варианта Decimal, Octal, Hex or None.

od -An -c file1
 320 241 320 273 320 260 320 262 320 260  \n 320 241 320 273 320
 260 320 262 320 260  \n 320 232 320 270 321 200 320 260  \n 320
 230 321 200 320 260  \n 320 232 320 270 321 200 320 260  \n 320
 230 321 200 320 270 320 275 320 260  \n 320 222 321 217 321 207
 320 265 321 201 320 273 320 260 320 262  \n 320 257 321 200 320
 276 321 201 320 273 320 260 320 262  \n 320 241 320 260 320 262
 320 265 320 273 320 270 320 271  \n  \n


od -Ad -c file1
0000000 320 241 320 273 320 260 320 262 320 260  \n 320 241 320 273 320
0000016 260 320 262 320 260  \n 320 232 320 270 321 200 320 260  \n 320
0000032 230 321 200 320 260  \n 320 232 320 270 321 200 320 260  \n 320
0000048 230 321 200 320 270 320 275 320 260  \n 320 222 321 217 321 207
0000064 320 265 321 201 320 273 320 260 320 262  \n 320 257 321 200 320
0000080 276 321 201 320 273 320 260 320 262  \n 320 241 320 260 320 262
0000096 320 265 320 273 320 270 320 271  \n  \n
0000106


#Ключ -c превращает всё просто в восьмеричный формат (для одного байта). Пример выше.
#Ключ -w используется для указания кол-ва байтов в строке.

od -Ad -c -w40 file1
0000000 320 241 320 273 320 260 320 262 320 260  \n 320 241 320 273 320 260 320 262 320 260  \n 320 232 320 270 321 200 320 260  \n 320 230 321 200 320 260  \n 320 232
0000040 320 270 321 200 320 260  \n 320 230 321 200 320 270 320 275 320 260  \n 320 222 321 217 321 207 320 265 321 201 320 273 320 260 320 262  \n 320 257 321 200 320
0000080 276 321 201 320 273 320 260 320 262  \n 320 241 320 260 320 262 320 265 320 273 320 270 320 271  \n  \n
0000106

#В целом формат вывода можно задать, как через отдельные ключи, так и через -t (--format=type). Однако не все имена форматов совпадают с названием отдельного ключа.
#То есть -с это тоже самое что и -tc, но -d = -tu2.


 -a     same as -t a,  select named characters, ignoring
              high-order bit

       -b     same as -t o1, select octal bytes

       -c     same as -t c,  select printable characters or backslash
              escapes

       -d     same as -t u2, select unsigned decimal 2-byte units

       -f     same as -t fF, select floats

       -i     same as -t dI, select decimal ints

       -l     same as -t dL, select decimal longs

       -o     same as -t o2, select octal 2-byte units

       -s     same as -t d2, select decimal 2-byte units

       -x     same as -t x2, select hexadecimal 2-byte unit

#Выше приведена вся таблица с ключами и соответствующими значениями формата для -t. Покажу на примере -b (выводит восьмеричные значения символов, без исключений в виде непечатаемых знаков, которые выводит -c).

od -Ad -to1 -w40 file1
0000000 320 241 320 273 320 260 320 262 320 260 012 320 241 320 273 320 260 320 262 320 260 012 320 232 320 270 321 200 320 260 012 320 230 321 200 320 260 012 320 232
0000040 320 270 321 200 320 260 012 320 230 321 200 320 270 320 275 320 260 012 320 222 321 217 321 207 320 265 321 201 320 273 320 260 320 262 012 320 257 321 200 320
0000080 276 321 201 320 273 320 260 320 262 012 320 241 320 260 320 262 320 265 320 273 320 270 320 271 012 012
0000106

od -Ad -b -w40 file1
0000000 320 241 320 273 320 260 320 262 320 260 012 320 241 320 273 320 260 320 262 320 260 012 320 232 320 270 321 200 320 260 012 320 230 321 200 320 260 012 320 232
0000040 320 270 321 200 320 260 012 320 230 321 200 320 270 320 275 320 260 012 320 222 321 217 321 207 320 265 321 201 320 273 320 260 320 262 012 320 257 321 200 320
0000080 276 321 201 320 273 320 260 320 262 012 320 241 320 260 320 262 320 265 320 273 320 270 320 271 012 012
0000106
-----------------------------------SUM-------------------------------------------
#Данная команда выводит подсчёт 16-битной контрольной суммы и кол-во блоков в файле.
#Используется это исключительно для проверки файла на повреждения или на правильность передачи данных по каналам связи.
#Это наверное самая пустая команда из всех, которая имеет всего-лишь 2 ключа (-r и -s), которые различаются по методам вычисления контрольной суммы.

sum file1
58232     1
sum -r file1
58232     1
sum -s file1
18108 1 file1

#Собственно -r это вычисление контрольных сумм как в BSD с размером блока 1 кб, а -s как в System V и размером блока в 512 байт. 
#По сути, есть ещё куча разных команд для подсчёт контрольных сумм по различным алгоритмам (MD5, CRC и так далее), но их мы разберём позже.
------------------------------------CUT------------------------------------------
#Данная команда используется для вырезания фрагментов текста из файла или потока ввода. Она так же удаляет секции текста, обоначеннные
# с помощью байтов, символов или полей, которые разделены "-" / ":".
#Работает аналогично сочетанию клавиш Ctrl + X, а количество выделяемого текста мы указываем с помощью ключей.
===file1===
Auto Brands
Audi
Daimler
Toyota
Volkswagen
Porsche

Volkswagen Polo стал одним из самых продаваемых автомобилей 2021 года.

cut -b 2 <file1
u
u
a
o
o
o

o

#С помощью ключа -b мы указали какой именно байт нам нужно вырезать (обратите внимание, что команда вырезает этот самый байт в каждой строке отдельно).
#То есть на каждой новой строке отсчёт байтов идёт с нуля.
#Чтобы указать промежуток байтов используем "-", а чтобы перечислить нужные нам позиции байтов, используем ",".
cut -b 2,3,5 <file1
ut
ud
ail
oyt
ols
orc

ols
cut -b 2-5 <file1
uto
udi
aiml
oyot
olks
orsc

olks

 cut -b 1-16 file2
Был холо▒

В вестиб▒

В кварти▒

Мир снар▒

За спино▒
#Не хватает байтов чтобы считать до конца знак кириллицы.
#Вот так вот можно исправить
cut -b 1-17 file2
Был холод

В вестибю

В квартир

Мир снару

За спиной

#Также интересно ещё и то, что выбор байтов имеет очень гибкий инструментарий, во многом похожий на slices в python.
#Вы можете указать промежуток "-b 10-", который выведет все байты с 10 по последний. Аналогично можно сделать от нуля.
#Есть ещё ключ -c, который работает с символами, но по сути в тексте разницу не увидеть (ну или я просто не смог).
#Перейдём к более интересному ключу -d и -f, которые взаимодействуют с текстом, как с набором столбцов.
#Эти ключи делят текст на столбцы по разделителям (пробелам, двоеточию, дефису или любой другой, который вы укажете сами).
#Важно отметить, что разделитель должен быть 1-байтовым, то есть вы не сможете использовать \n или кириллицу.
#Но, ключ -d сам по себе ничего не делает, мы должны указать, какой именно столбец мы хотим взять из полученного разделения.
#Тут уже работает ключ -f. Для этого ключа можно использовать все те же вариации, что и с -b.
cut -d 'o' -f 1 file1
Aut
Audi
Daimler
T
V
P

V
cut -d ' ' -f 1 file2
Был

В

В

Мир

За
#Разделитель по умолчанию - табуляция.
----------------------------------VIM-------------------------------------------
#В ОС Linux есть несколько текстовых редакторов, один из них - VI/VIM.
#VIM - Vi Improved, то есть улучшенный текстовый редактор Vi.
#Редактор использует два режима (командный и редактирования).
#В командном режиме вы можете с помощью клавиш выбирать те или иные функции редактора, а используя 
# режим редактора - непосредственно редактировать текст, как в любом другом редакторе (nano).
#Чтобы попасть в командный режим используется ESC, чтобы попасть в режим редактирования используется i.
#Не указывая файл после команды Vim, будет создан новый файл.
#Если же с помощью редактора Vim открыть существующий файл, то с помощью +n,
# можно открыть файл с курсором в начале n-ой строки.
#С помощью +/ можно найти шаблон слова, на которое будет переведён курсор при открытии файла.
#С помощью ключа -d можно вызвать разделение экрана для сравнения нескольких файлов. (Нужно указать более 1 файла в параметры).
#Ключ -R позволяет открыть файл в режиме только для чтения. 
#Я не совсем представляю, как показать все возможности редактора, поэтому просто их перечислю в виде текста.
#Когда мы только открываем редактор, мы находимся в командном режиме, где в качестве команд выступают буквенные клавиши.
#Ниже указаны команды перемещения (для перемещения по буквам также работают обычные стрелочки).
h - на один символ влево;
l - на один символ вправо;
j - на одну строку вниз;
k - на одну строку вверх;
w - на слово вправо;
b - на слово влево;
H - перейти в низ экрана;
G - перейти в конец файла;

#Отдельно стоит сказать о том, что удобство этих команд заключается в том, что их можно выполнять заданное количество раз.
#Для этого перед тем, как указывать саму команду надо написать число её повторений (3h). Такая команда передвинет курсор на 3 символа влево.
#Для перехода в режим редактирования так же есть удобные команды, которые упрощают нашу работу.
i - вставить текст с позиции курсора;
I - вставить текст в начало строки;
a - добавить текст начиная от позиции курсора;
o/O - вставить новую строку после этой и начать редактирование;

r - заменить текущий символ 
#(можно нажать r, а следом символ, которым хотим заменить и мы сразу же вернёмся в командный режим);

R - заменить несколько символов.
#(Начнёт заменять символы по одному начиная с того, где стоит курсор. При нажатии backspace, изменения будут возвращаться назад так же по одному символу).

#Более того изменять файл можно и в командном режиме, для этого существуют такие команды:
d - удалить символ;
dd - удалить всю строку;
#Здесь может возникнуть проблема с реализацией первой команды вместо второй, поэтому, лично я просто пишу команду (3d) и дальше использую стрелочку, чтобы команда выполнилась.
#Вместо этого можно и порой даже удобнее будет использовать команды перемещений, но мне уже просто привычнее стрелками.
#Стоит упомянуть, что нажатая стрелка или команда после удаления имеет важную роль. Например, если вы напишите 3d и нажмёте стрелку влево (аналогично 3dh), то вы удалите 3 символа влево от курсора.
#Аналогично будет с другими командами и стрелками.
(Если же вы пропишите сразу 2dd, то команда выполнится, не дожидаясь каких-либо других действий. Очевидно, с чем это связано).
#Да,почти со всеми командами работает повторение, эти не исключение.

D - удалить символы начиная от курсора и до конца строки;
y - копировать символ (в буфер);
yy или Y - скопировать всю строку;
v - выделить текст;
#Тоже самое, что выделить текст мышкой, а потом применить к этому какие-либо действия.
#Можно выделить текст с помощью нажатия на v, а потом ещё раз нажать d, и весь выделенный текст будет удалён.
#Копировать научились, осталось вставлять текст:
p - вставить после позиции курсора;
P - вставить перед позицией курсора;
u - отменить последнее действие;
. - повторить еще раз последнее действие;
U - отменить последнее действие в текущей строке;
/шаблон - искать вхождение;
:%s/шаблон/заменить - заменить первое слово на второе;
n - продолжить поиск вперед;
N - продолжить поиск назад;
#Для новичка самое сложное в редакторе - выйти из него, поскольку привычные ctrl+с или q тут не сработают.
#Для управления самим файлом и редактором используется командная строка Vim, которая понимает, что сейчас будут команды связанные больше с файлом, нежели с его содержимым.
:w - сохранить файл;
:q - закрыть редактор;
:q! - закрыть редактор без сохранения;
:e файл - прочитать содержимое файла в позицию курсора;
:r файл - вставить содержимое файла в следующую строку;
:r! - выполнить команду оболочки и вставить ответ в редактор;
:set переменная=значение - установить значение переменной, например, tabstop=4, или set number, с помощью этой команды можно управлять многими аспектами работы vim.
:buffers - посмотреть открытые файлы.

#Большая часть команда вроде интуитивно понятна, оставляет вопрос лишь set. Если вы зайдёте в Vim и у вас будет выбрана русская раскладка, то вы не сможете вызвать ни одной команды.
#Поэтому, учтите, что вам предстоит всегда переключаться на английскую раскладку.
#Стоит также отметить, что VIM это прямо отдельная очень крупная тема, этот редактор настолько популярен, что для него есть десятки плагинов, куча настроев отступов, которые повторяют PEP-8 (стандарт Python) и так далее.
#Поэтому всё об этой команде сказать просто невозможно.
-----------------------------------MC-------------------------------------------
MC - Midnight Commander - файловый менеджер в консоли.
#Это опять графическая утилита, которую особо нет смысла рассматривать в рамках текстового решения лабы.

----------------------------------AWK-------------------------------------------
#Очередной инструмент для обработки и фильтрации текста в Linux, коих очень много.
#Команда работает с текстом построчно (принимает сначала первую строку, обрабатывает её и отдаёт в поток выхода).
#Более того это целый отдельный язык для работы с текстом.
 awk '{print $1}' <file1
Auto
Audi
Daimler
Toyota
Volkswagen
Porsche

Volkswagen
#Здесь в качестве вывода используется print(), а $ указывает на номер колонки (столбца).
awk '{print 1}' <file1
1
1
1
1
1
1
1
1
#Убрав доллар, мы уже получим работу команды print(строка), которая просто заполняет строку указанным значением.
#Вот список основных функций действий:
print(строка) - вывод чего либо в стандартный поток вывода;
printf(строка) - форматированный вывод в стандартный поток вывода;
system(команда) - выполняет команду в системе;
length(строка) - возвращает длину строки;
substr(строка, старт, количество) - обрезает строку и возвращает результат;
tolower(строка) - переводит строку в нижний регистр;
toupper(строка) - переводить строку в верхний регистр.

#А вот переменные и операторы, которые можно использовать в командах-действиях:
FNR - номер обрабатываемой строки в файле;
FS - разделитель полей;
NF - количество колонок в данной строке;
NR - общее количество строк в обрабатываемом тексте;
RS - разделитель строк, по умолчанию символ новой строки;
$ - ссылка на колонку по номеру.

#Командам можно передавать несколько аргументов через запятую. 
awk '{print ($1, $5)}' <file2
Был день,

В капустой

В что-то

Мир окнами,

За из

#Вспомним и про ключи. Если нам нужно поделить текст на столбцы не пробелами, а другим разделяющим знаком, то следует использовать ключ -F (--field-separator)
# и в кавычках указать нужный разделитель.
#Если мы захотим обратиться к последней колонке или к середине, то мы можем поиграть с параметром NF (указать его, разделить на двое и так далее).
#Более того, с awk можно использовать условия (как в полноценном ЯП), при которых строка будет обрабатываться.
#А если есть условия, значит есть и переменные. Ключ -v(--asign) позволяет присваивать какое-либо значение переменной.
$ echo -e 'odin 1 \n two 2 \n five 5' | awk '{sum+=$2} END {print sum}'
8

$ echo -e 'odin 1 \n two 2 \n five 5' | awk -v sum=2 '{sum+=$2} END {print sum}'
10

#На примерах выше мы прекрасно видим в действии работу ключа -v, а также оператора END, указывающего на конец считывания.

echo -e 'odin 1 \n two 2 \n five 5' | awk -v sum=2 '{sum+=$2} /two/ {print sum}'
5
#В данном примере продемонстрирована работа условия (print активируется только тогда, когда встретит two и больше никогда).
#Слева от действия, которое пишется в фигурных скобках указывается условие и это условие влияет ТОЛЬКО на действие справа.
#Важно не путаться в условиях.
#Ключ -f используется для указания файла с командами на выполнение (когда вручную вводить очень долго и неудобно).
#Неочевидным решением является такой вывод:
awk 'length($0) > 10' <file1
Auto Brands
Volkswagen Polo
#AWK может выводить строки просто по условию, то есть, если он находит строку подходящую по условию, он по умолчанию её выведет. Если не указано другого действия.
----------------------------------SED-------------------------------------------
#SED - потоковый редактор текста, который позволяет производить замены текста, вставку и удаление не открывая самого файла.
#Для использования данной команды с очень большой вероятностью потребуются знания регулярных выражений.
#Пройдёмся сразу по ключам, а потом перейдём к примерам.
#Ключ -f мы уже встречали, он передаёт файл, в котором содержатся инструкции по редактированию. 
#Ключ -i заносит все изменения сразу в файл (резервная копия создаётся, если указан суффикс - дополнение к оригинальному названию файла).
#Ключ -r включает поддержку расширенного списка регулярных выражений (Разница заключается в поведении определённых операторов).
#Ключ с которым мы будем работать всегда -e, который указывает, какие команды надо выполнить для редактирования.
#Команда работает с файлами построчно, убирает все завершающие символы и переносы строки, помещает строку в буфер шаблона. Затем выполняются команды редактирования.
#После выполнения команд, если не используются специальные команды, то буфер очищается, а строка идёт в поток вывода.
#Команды можно совмещать с условиями, которые будут указывать на то, в каком случае выполнять команду, а когда нет.

#Эти условия называются адресами, они могут содержать в себе либо регулярные выражения, указывающие на строку, либо на номер строки, можно также указать n-ое количество строк после начала изменений.
#Диапазон адресов задаётся с помощью запятой.
номер - позволяет указать номер строки, в которой надо выполнять команду;
первая~шаг - команда будет выполняется для указанной в первой части строки, а затем для всех с указанным шагом;
$ - последняя строка в файле;
/регулярное_выражение/ - любая строка, которая подходит по регулярному выражению. Модификатор l указывает, что регулярное выражение должно быть не чувствительным к регистру;
номер, номер - начиная от строки из первой части и заканчивая строкой из второй части;
номер, /регулярное_выражение/ - начиная от сроки из первой части и до сроки, которая будет соответствовать регулярному выражению;
номер, +количество - начиная от номера строки указанного в первой части и еще плюс количество строк после него;

#Ну и последний пункт теории - сами команды SED.
# - комментарий, не выполняется;
q - завершает работу сценария;
d - удаляет буфер шаблона и запускает следующую итерацию цикла;
p - вывести содержимое буфера шаблона;
n - вывести содержимое буфера шаблона и прочитать в него следующую строку;
s/что_заменять/на_что_заменять/опции - замена символов, поддерживаются регулярные выражения;
y/символы/символы - позволяет заменить символы из первой части на соответствующие символы из второй части;
w - записать содержимое буфера шаблона в файл;
N - добавить перевод строки к буферу шаблона;
D - если буфер шаблона не содержит новую строку, удалить его содержимое и начать новую итерацию цикла, иначе удалить содержимое буфера до символа перевода строки и начать новую итерацию цикла с тем, что останется;
g - заменить содержимое буфера шаблона, содержимым дополнительного буфера;
G - добавить новую строку к содержимому буфера шаблона, затем добавить туда же содержимое дополнительного буфера.

#Грубо говоря, команда SED это некий язык программирования, которые указывает, что надо делать с текстом в файле. Чтобы передать много команд, их следует разделить точкой с запятой.
#Ещё один важный момент, если команда одна, то ключ -e необязателен.
#Ключ -n позволяет не выводить нам буфер шаблона на каждой итерации (проще говоря, не захламляет нам вывод).
sed -n '1,8p' file4
VAAAAAAGGGvaaaaaaaaaaag
Volkswagen
Toyota
Rolls-Royce
BMW
Audi
Lancia
Renault

sed -n -e '1,8p' file4
VAAAAAAGGGvaaaaaaaaaaag
Volkswagen
Toyota
Rolls-Royce
BMW
Audi
Lancia
Renault

#Вывод без -n
sed '1,8p' file4
VAAAAAAGGGvaaaaaaaaaaag
VAAAAAAGGGvaaaaaaaaaaag
Volkswagen
Volkswagen
Toyota
Toyota
Rolls-Royce
Rolls-Royce
BMW
BMW
Audi
Audi
Lancia
Lancia
Renault
Renault
Ford
Chevrolet
Honda
McLaren
Ferrari
Porsche
Lada
UAZ
Volkswagen

===file4===
Toyota
Rolls-Royce
BMW
Audi
Lancia
Renault
Ford
Chevrolet
Honda
McLaren
Ferrari
Porsche
Lada
UAZ
Volkswagen

#Вывод с первой строки с последующим шагом в 5 строк.
sed -n '1~5p' file4
Toyota
Renault
Ferrari

#А вот уже пример с несколькими командами. Здесь мы исключаем 3 - 7 строки и выводим все остальные. Это можно было сделать проще, убрав вторую команду и убрав ключ -n.
sed -n -e '3,7d; p' file4Toyota                 
Rolls-Royce
Chevrolet
Honda
McLaren
Ferrari
Porsche
Lada
UAZ
Volkswagen

sed -e '3,7d' file4
Toyota
Rolls-Royce
Chevrolet
Honda
McLaren
Ferrari
Porsche
Lada
UAZ
Volkswagen

#Теперь продемонстрируем замену в SED.
sed -e 's/a/ZA/i' file4
ToyotZA
Rolls-Royce
BMW
ZAudi
LZAncia
RenZAult
Ford
Chevrolet
HondZA
McLZAren
FerrZAri
Porsche
LZAda
UZAZ
VolkswZAgen

rokivals@RoKi:~/Документы/Информатика/Лабы/temp_files$ sed -e 's/a/ZA/gi' file4
ToyotZA
Rolls-Royce
BMW
ZAudi
LZAnciZA
RenZAult
Ford
Chevrolet
HondZA
McLZAren
FerrZAri
Porsche
LZAdZA
UZAZ
VolkswZAgen

#В конце выражения указываются опции. Например g - заменяет все вхождения, а не только первое, разница продемонстрирована в примерах выше. Опция i - игнорирует регистр букв.
P.S. Изначально вообще была ZAMENA, а ZA оставил потому что так короче, никакого подтекста...

sed -i1 '/^#\|^$\| #/d' file1
rokivals@RoKi:~/Документы/Информатика/Лабы/temp_files$ ls
1984  file1  file11  file2  file3  file4

#Ключ -i работает по такому принципу, что после него надо указать суффикс, который добавится к оригинальному названию и так создастся резервная копия файла.

----------------------------------HEAD-------------------------------------------
#Одна из самых простых и понятных команд в этой лабораторке. По умолчанию выводит первые 10 строк файла. Может ещё показывать данные, передаваемые на вывод другой утилитой (командой).
#Ключ -c (--bytes) позволяет задать количество выводимого текста в байтах, а не в строках. Запись вида --bytes=-n позволяет вывести на экран всё содержимое файла, кроме последних n байтов.
#Ключ -n (--lines) указывает кол-во выводимых строк. Также, аналогичным способом можно вывести все строки, кроме n последних, как с ключом -c.
#Ключ -q (--quiet) выводит только текст, без названия файла.
#Ключ -v (--verbose) выводит перед текстом название файла.
===file1===
Список стран и автопроизводителей созданных в них.

Австралия:
1) Daytona Motors
2) Hammer

Бельгия:
1) ALP
2) Astra

Канада:
1) Plymouth
2) Russell Motor

Китай:
1) Chery Automobile Co
2) Foton Motor
3) Lifan

Чехия:
1) Škoda Auto

Франция:
1) Alpine
2) Bugatti
3) Citroën
4) Peugeot
5) Renault

Германия:
1) Audi
2) Auto-Union
3) BMW
4) Daimler
5) Koenig
6) Maybach
7) Mercedes-Benz
8) Opel
9) Porsche
10) Ruf Automobile GmbH
11) Vauxhall
12) Volkswagen

Италия: 
1) Abarth
2) Ferrari
3) Fiat
4) Pagani

Швеция:
1) Koenigsegg
2) Saab
3) Scania
4) Volvo


#Дальше будут приведены примеры использования команды HEAD:

head file1
Список стран и автопроизводителей созданных в них.

Австралия:
1) Daytona Motors
2) Hammer

Бельгия:
1) ALP
2) Astra

head -v file1
==> file1 <==
Список стран и автопроизводителей созданных в них.

Австралия:
1) Daytona Motors
2) Hammer

Бельгия:
1) ALP
2) Astra

head -v -n 15 file1
==> file1 <==
Список стран и автопроизводителей созданных в них.

Австралия:
1) Daytona Motors
2) Hammer

Бельгия:
1) ALP
2) Astra

Канада:
1) Plymouth
2) Russell Motor

Китай:

head -v --lines=-25 file1
==> file1 <==
Список стран и автопроизводителей созданных в них.

Австралия:
1) Daytona Motors
2) Hammer

Бельгия:
1) ALP
2) Astra

Канада:
1) Plymouth
2) Russell Motor

Китай:
1) Chery Automobile Co
2) Foton Motor
3) Lifan

Чехия:
1) Škoda Auto

Франция:
1) Alpine
2) Bugatti
3) Citroën
4) Peugeot
5) Renault

Германия:

#И как я уже говорил, head может читать вывод других команд. Почему бы не передать вывод head на вход тому же head?.. Работает? - Работает!
head -v --lines=-25 file1 | head -n 20
==> file1 <==
Список стран и автопроизводителей созданных в них.

Австралия:
1) Daytona Motors
2) Hammer

Бельгия:
1) ALP
2) Astra

Канада:
1) Plymouth
2) Russell Motor

Китай:
1) Chery Automobile Co
2) Foton Motor
3) Lifan
----------------------------------MD5SUM-------------------------------------------
#Это разновидность команд для вычисления контрольной суммы. Данная утилита использует одноимённый алгоритм.
#MD5 сумма это 128 битная строка, которая состоит из букв и цифр. Контрольные суммы используются для сравнения файлов друг с другом, чаще всего это делается в протоколах передачи данных для проверки на корректность передачи и отсутствие потерь. Поскольку, время - деньги, а сравнивать два файла в лоб, тем более по сети - неудобно и долго, то придумали контрольные суммы, которые для полностью одинаковых файлов на любых ЭВМ всегда идентичны. Крайне редко встречаются два разных файла, дающие одну и ту же контрольную сумму.
#Ниже продемонстрировано, что изменение названия файла никак не влияет на контрольную сумму.
md5sum 1984 
79551e53d4faeda28ad582959984b65f  1984
rokivals@RoKi:~/Документы/Информатика/Лабы/temp_files$ nano 1984 
rokivals@RoKi:~/Документы/Информатика/Лабы/temp_files$ ls
1984  1984.txt  file1  file2  file3  file4
rokivals@RoKi:~/Документы/Информатика/Лабы/temp_files$ md5sum 1984.txt 
79551e53d4faeda28ad582959984b65f  1984.txt
rokivals@RoKi:~/Документы/Информатика/Лабы/temp_files$ md5sum 1984.txt  1984
79551e53d4faeda28ad582959984b65f  1984.txt
79551e53d4faeda28ad582959984b65f  1984

#Можно ещё автоматизировать процесс проверки файла на его целостность. Сохранить результат md5 в файл, а потом проверять его (но тогда нельзя менять имя файла).

md5sum  1984 > 1984.txt 
md5sum -c 1984.txt 
1984: ЦЕЛ

#Вот что получим при изменении
md5sum -c 1984.txt 
1984: ПОВРЕЖДЁН
md5sum: ПРЕДУПРЕЖДЕНИЕ: НЕ совпала 1 вычисленная контрольная сумма
----------------------------------DU-------------------------------------------
#Команда, которая позволяет узнать размер файлов в заданных единицах измерения.
#По умолчанию размер выводится только для каталогов, поэтому ключ -a (--all) позволяет выводить размеры для всех файлов (он ещё и работает как рекурсивный вывод внутрь папок).
du
124	./Лабораторная 20
76	./temp_files
204	.

du -a
120	./Лабораторная 20/lab20.txt
124	./Лабораторная 20
4	./temp_files/file4
52	./temp_files/1984
4	./temp_files/file3
4	./temp_files/file1
4	./temp_files/1984.txt
4	./temp_files/file2
76	./temp_files
204	.

#Самая последняя строка выводит нам размер папки, откуда вызвана команда, можно вывести такую же строку, но со словом итого с помощью ключа -c.
du -c
124	./Лабораторная 20
76	./temp_files
204	.
204	итого

#Мы уже заметили рекурсивный обход папок, поэтому его можно ограничить кол-вом углублений с помощью -d.
du Информатика/
24	Информатика/Зачёт
124	Информатика/Лабы/Лабораторная 20
76	Информатика/Лабы/temp_files
204	Информатика/Лабы
232	Информатика/


du -d1 Информатика/
24	Информатика/Зачёт
204	Информатика/Лабы
232	Информатика/

#Можно вывести размер только основной папки (ключ -s, либо -d0)
du -h -s Информатика/
232K	Информатика/
rokivals@RoKi:~/Документы$ du -hd0  Информатика/
232K	Информатика/
----------------------------------FILE-------------------------------------------
#Утилита позволяющая определять тип данных у файлов.
file 1984 file1
1984:  UTF-8 Unicode text, with very long lines
file1: UTF-8 Unicode text

#Ключ -i для вывода MIME-типа файла. (Это что-то вроде классификации файлов, которые можно передать по интернету).
file -i 1984 file1
1984:  text/plain; charset=utf-8
file1: text/plain; charset=utf-8

file 101
101: cannot open `101' (No such file or directory)

#С ключом -E можно добавить заметный для глаза и очень полезный ERROR
file -E 101
101: ERROR: cannot stat `101' (No such file or directory)
----------------------------------FIND-------------------------------------------
#Утилита для поиска файлов и каталогов в системе Linux.
#По своему синтаксису наверное одна из самых сложных команд. find [папка] [параметры] критерий шаблон [действие].

Папка - каталог в котором будем искать

Параметры - дополнительные параметры, например, глубина поиска, и т д

Критерий - по какому критерию будем искать: имя, дата создания, права, владелец и т д.

Шаблон - непосредственно значение по которому будем отбирать файлы.

#Уже немало информации, а дальше будет ещё больше. Начнём с ключей 
# -maxdepth - максимальная глубина поиска по подкаталогам, для поиска только в текущем каталоге установите 1.
# -depth - искать сначала в текущем каталоге, а потом в подкаталогах.
# -print - выводить полные имена файлов (стоит по умолчанию).
# -type f - искать только файлы.
# -type d - поиск папки в Linux.

find Лабы/ -type d 
Лабы/
Лабы/Лабораторная 20
Лабы/temp_files


find Лабы/ -type f
Лабы/Лабораторная 20/lab20.txt
Лабы/temp_files/file4
Лабы/temp_files/1984
Лабы/temp_files/file3
Лабы/temp_files/file1
Лабы/temp_files/1984.txt
Лабы/temp_files/file2


find Лабы/ -maxdepth 1
Лабы/
Лабы/Лабораторная 20
Лабы/temp_files

find Лабы/ -maxdepth 0
Лабы/

#Теперь затронем критерии:

    -name - поиск файлов по имени.
    -perm - поиск файлов в Linux по режиму доступа.
    -user - поиск файлов по владельцу.
    -group - поиск по группе.
    -mtime - поиск по времени модификации файла.
    -atime - поиск файлов по дате последнего чтения.
    -nogroup - поиск файлов, не принадлежащих ни одной группе.
    -nouser - поиск файлов без владельцев.
    -newer - найти файлы новее чем указанный.
    -size - поиск файлов в Linux по их размеру.


#Для поиска из текущей директории можно использовать просто find или "find ."
find . -print
.
./Зачёт
./Зачёт/final.txt
./Зачёт/filter.sh
./Зачёт/result.txt
./Зачёт/file1.txt
./Зачёт/file.txt
./Лабы
./Лабы/Лабораторная 20
./Лабы/Лабораторная 20/lab20.txt
./Лабы/temp_files
./Лабы/temp_files/file4
./Лабы/temp_files/1984
./Лабы/temp_files/file3
./Лабы/temp_files/file1
./Лабы/temp_files/1984.txt
./Лабы/temp_files/file2

#Поиск файлов по имени:

find . -name "19*"
./Лабы/temp_files/1984
./Лабы/temp_files/1984.txt

#Чтобы игнорировать регистр используем наш любимый ключ -i.

find . -iname "FIlE*"
./Зачёт/file1.txt
./Зачёт/file.txt
./Лабы/temp_files/file4
./Лабы/temp_files/file3
./Лабы/temp_files/file1
./Лабы/temp_files/file2

#Можем задать обратный шаблок для поиска (то есть найдёт все файлы, которые не соответствуют шаблону). Для этого -not критерий:

find . -not -iname "FIlE*"
.
./Зачёт
./Зачёт/final.txt
./Зачёт/filter.sh
./Зачёт/result.txt
./Лабы
./Лабы/Лабораторная 20
./Лабы/Лабораторная 20/lab20.txt
./Лабы/temp_files
./Лабы/temp_files/1984
./Лабы/temp_files/1984.txt

#Хочу отдать должное, find правда очень интересная утилита в которой даже можно задавать полноценные условия поиска. Файл начинается на file, но не должен заканчиваться на 3/4.
#Это полноценное логическое условие. Тут даже ИЛИ можно использовать.

find  . -name "file*" -not -iname "*[3-4]"
./Зачёт/file1.txt
./Зачёт/file.txt
./Лабы/temp_files/file1
./Лабы/temp_files/file2

# Для ИЛИ используется -o.

find  . -name "file*" -o -iname "19*"
./Зачёт/file1.txt
./Зачёт/file.txt
./Лабы/temp_files/file4
./Лабы/temp_files/1984
./Лабы/temp_files/file3
./Лабы/temp_files/file1
./Лабы/temp_files/1984.txt
./Лабы/temp_files/file2

#Вот так можно искать в нескольких каталогах сразу:
find /usr/ /sys/ -name "*.c"

#Вывод большой, поэтому верьте на слово.

#Для поиска скрытых файлов, которые начинаются с точки, можно использовать:
find /usr/ /sys/ -type f -name ".*"

#Для поиска файлов, которые принадлежат какому-то пользователю используется:
find /usr/ /sys/ -user rokivals

#Поиск файлов по размеру. Ниже мы ищем файлы которые равны 20МБ:
find /usr/ -size 20M
/usr/lib/firmware/liquidio/lio_23xx_vsw.bin
/usr/share/fonts/opentype/noto/NotoSansCJK-Regular.ttc
/usr/share/fonts/opentype/noto/NotoSansCJK-Bold.ttc


#А вот так ищутся файлы от 10 до 20 МБ:
find /usr/ -size +10M -size -20M
/usr/lib/x86_64-linux-gnu/libvulkan_intel.so
/usr/lib/x86_64-linux-gnu/libcodec2.so.0.9
/usr/lib/x86_64-linux-gnu/dri/i915_dri.so
/usr/lib/x86_64-linux-gnu/dri/radeonsi_drv_video.so
/usr/lib/x86_64-linux-gnu/dri/r200_dri.so
/usr/lib/x86_64-linux-gnu/dri/nouveau_drv_video.so
/usr/lib/x86_64-linux-gnu/dri/i830_dri.so
/usr/lib/x86_64-linux-gnu/dri/nouveau_vieux_dri.so
/usr/lib/x86_64-linux-gnu/dri/r600_drv_video.so
/usr/lib/x86_64-linux-gnu/dri/radeon_dri.so
/usr/lib/x86_64-linux-gnu/dri/i965_dri.so
/usr/lib/x86_64-linux-gnu/libasan.so.5.0.0
/usr/lib/x86_64-linux-gnu/vdpau/libvdpau_r600.so.1.0.0
/usr/lib/x86_64-linux-gnu/vdpau/libvdpau_r300.so.1.0.0
/usr/lib/x86_64-linux-gnu/vdpau/libvdpau_radeonsi.so.1.0.0
/usr/lib/x86_64-linux-gnu/vdpau/libvdpau_nouveau.so.1.0.0
/usr/lib/x86_64-linux-gnu/libavcodec.so.58.54.100
/usr/lib/x86_64-linux-gnu/libx265.so.179
/usr/lib/x86_64-linux-gnu/libgs.so.9.50
/usr/lib/jvm/java-11-openjdk-amd64/lib/server/classes.jsa
/usr/lib/jvm/java-11-openjdk-amd64/lib/server/libjvm.so
/usr/lib/debug/lib/x86_64-linux-gnu/libc-2.31.so
/usr/lib/debug/lib/libc6-prof/x86_64-linux-gnu/libc-2.31.so
/usr/lib/libreoffice/program/libsclo.so
/usr/lib/libreoffice/program/libswlo.so
/usr/lib/snapd/snap-repair
/usr/lib/snapd/snap-recovery-chooser
/usr/lib/snapd/snap-preseed
/usr/lib/snapd/snap-bootstrap
/usr/bin/audacity
/usr/share/fonts/truetype/noto/NotoColorEmoji.ttf
/usr/share/mythes/th_en_AU_v2.dat
/usr/share/mythes/th_en_US_v2.dat

#С помощью ключа -empty можно искать пустые файлы или папки.
find
.
./Зачёт
./Зачёт/final.txt
./Зачёт/filter.sh
./Зачёт/result.txt
./Зачёт/file1.txt
./Зачёт/file.txt
./Лабы
./Лабы/Лабораторная 20
./Лабы/Лабораторная 20/lab20.txt
./Лабы/temp_files
./Лабы/temp_files/file4
./Лабы/temp_files/1984
./Лабы/temp_files/file3
./Лабы/temp_files/file1
./Лабы/temp_files/1984.txt
./Лабы/temp_files/file2
./alah

 find -empty
./alah


#После find можно вызвать ещё и выполнение каких-либо команд. Вот так можно к каждому найденному файлу или папке применить ls с помощью ключа -exec.
find . -exec ls -ld {} \;
drwxrwxr-x 4 rokivals rokivals 4096 апр 21 17:09 .
drwxrwxr-x 2 rokivals rokivals 4096 мая 19 12:59 './Лабораторная 20'
-rw-rw-r-- 1 rokivals rokivals 130937 мая 19 12:59 './Лабораторная 20/lab20.txt'
drwxrwxr-x 2 rokivals rokivals 4096 мая 18 20:53 ./temp_files
-rw-rw-r-- 1 rokivals rokivals 109 мая  3 21:37 ./temp_files/file4
-rw-rw-r-- 1 rokivals rokivals 49281 мая 18 20:53 ./temp_files/1984
-rw-rw-r-- 1 rokivals rokivals 478 апр 23 00:41 ./temp_files/file3
-rw-rw-r-- 1 rokivals rokivals 660 мая  3 23:31 ./temp_files/file1
-rw-rw-r-- 1 rokivals rokivals 39 мая 18 20:52 ./temp_files/1984.txt
-rw-rw-r-- 1 rokivals rokivals 434 апр 22 00:04 ./temp_files/file2
----------------------------------XARGS-------------------------------------------
#Наверное это самая бесполезная утилита, потому что она просто реализует конвейер (да, не всегда там получится это сделать через конвейер, но всё же...).
#Команда просто передаёт вывод одной команды другой. И всё. Ну она ещё может работать с разделителями, всё такое, ну хоть чуть-чуть функционала то у неё должно быть.
#По ключам. 
# -d, --delimiter - указать разделитель строки, по умолчанию \n.
# -E, -e, --eof - индикатор конца файла, все символы после вхождения этой строки игнорируются
# -l, --max-lines - количество строк, передающихся в одну команду по умолчанию все;
# -n, --max-args - количество параметров, которые передаются в одну команду, по умолчанию все;
# -p, --interactive - спрашивать пользователя о запуске каждой следующей команды.
# -t, --verbose - максимально подробный вывод утилиты.

#Вот я передам ls в echo (фантазии просто не хватает на что-то большее)
#И как мы видим, ВЕСЬ вывод ls передался в echo одним текстом и получилась... КАША
ls -lR | xargs -t echo
echo .: итого 8 drwxrwxr-x 2 rokivals rokivals 4096 мая 18 20:53 temp_files drwxrwxr-x 2 rokivals rokivals 4096 мая 19 13:10 Лабораторная 20 ./temp_files: итого 72 -rw-rw-r-- 1 rokivals rokivals 49281 мая 18 20:53 1984 -rw-rw-r-- 1 rokivals rokivals 39 мая 18 20:52 1984.txt -rw-rw-r-- 1 rokivals rokivals 660 мая 3 23:31 file1 -rw-rw-r-- 1 rokivals rokivals 434 апр 22 00:04 file2 -rw-rw-r-- 1 rokivals rokivals 478 апр 23 00:41 file3 -rw-rw-r-- 1 rokivals rokivals 109 мая 3 21:37 file4 ./Лабораторная 20: итого 132 -rw-rw-r-- 1 rokivals rokivals 133391 мая 19 13:10 lab20.txt 
.: итого 8 drwxrwxr-x 2 rokivals rokivals 4096 мая 18 20:53 temp_files drwxrwxr-x 2 rokivals rokivals 4096 мая 19 13:10 Лабораторная 20 ./temp_files: итого 72 -rw-rw-r-- 1 rokivals rokivals 49281 мая 18 20:53 1984 -rw-rw-r-- 1 rokivals rokivals 39 мая 18 20:52 1984.txt -rw-rw-r-- 1 rokivals rokivals 660 мая 3 23:31 file1 -rw-rw-r-- 1 rokivals rokivals 434 апр 22 00:04 file2 -rw-rw-r-- 1 rokivals rokivals 478 апр 23 00:41 file3 -rw-rw-r-- 1 rokivals rokivals 109 мая 3 21:37 file4 ./Лабораторная 20: итого 132 -rw-rw-r-- 1 rokivals rokivals 133391 мая 19 13:10 lab20.txt

#С помощью ключа -l будем в echo передавать по одной строке:
ls -lR | xargs -t -l1 echo
echo .: 
.:
echo итого 8 
итого 8
echo drwxrwxr-x 2 rokivals rokivals 4096 мая 18 20:53 temp_files 
drwxrwxr-x 2 rokivals rokivals 4096 мая 18 20:53 temp_files
echo drwxrwxr-x 2 rokivals rokivals 4096 мая 19 13:12 Лабораторная 20 
drwxrwxr-x 2 rokivals rokivals 4096 мая 19 13:12 Лабораторная 20
echo ./temp_files: 
./temp_files:
echo итого 72 
итого 72
echo -rw-rw-r-- 1 rokivals rokivals 49281 мая 18 20:53 1984 
-rw-rw-r-- 1 rokivals rokivals 49281 мая 18 20:53 1984
echo -rw-rw-r-- 1 rokivals rokivals 39 мая 18 20:52 1984.txt 
-rw-rw-r-- 1 rokivals rokivals 39 мая 18 20:52 1984.txt
echo -rw-rw-r-- 1 rokivals rokivals 660 мая 3 23:31 file1 
-rw-rw-r-- 1 rokivals rokivals 660 мая 3 23:31 file1
echo -rw-rw-r-- 1 rokivals rokivals 434 апр 22 00:04 file2 
-rw-rw-r-- 1 rokivals rokivals 434 апр 22 00:04 file2
echo -rw-rw-r-- 1 rokivals rokivals 478 апр 23 00:41 file3 
-rw-rw-r-- 1 rokivals rokivals 478 апр 23 00:41 file3
echo -rw-rw-r-- 1 rokivals rokivals 109 мая 3 21:37 file4 
-rw-rw-r-- 1 rokivals rokivals 109 мая 3 21:37 file4
echo ./Лабораторная 20: 
./Лабораторная 20:
echo итого 132 
итого 132
echo -rw-rw-r-- 1 rokivals rokivals 134961 мая 19 13:12 lab20.txt 
-rw-rw-r-- 1 rokivals rokivals 134961 мая 19 13:12 lab20.txt

#Обратите внимание на то, что в каждой строке сначала выводится echo, а потом сама строка, это работа ключа -t.

#Я всё-таки смог придумать что-то интереснее... Чутка.
find . -type f -name "file*" | xargs -l1 wc
 16  15 109 ./temp_files/file4
  9  74 478 ./temp_files/file3
 55  94 660 ./temp_files/file1
  7  44 434 ./temp_files/file2

----------------------------------DF-------------------------------------------
#Утилита позволяет узнать информацию о пространстве на дисках.
df
df: /run/user/1000/doc: Операция не позволена
Файл.система   1K-блоков Использовано Доступно Использовано% Cмонтировано в
udev             2922472            0  2922472            0% /dev
tmpfs             593848         1164   592684            1% /run
/dev/sda5       61145932     15898820 42111368           28% /
tmpfs            2969232            0  2969232            0% /dev/shm
tmpfs               5120            4     5116            1% /run/lock
tmpfs            2969232            0  2969232            0% /sys/fs/cgroup
/dev/loop0        113280       113280        0          100% /snap/core/12834
/dev/loop1         89344        89344        0          100% /snap/sqlitebrowser/3233
/dev/sda1         523248            4   523244            1% /boot/efi
tmpfs             593844           24   593820            1% /run/user/1000

#Для более читаемого вывода, используем ключ -h.
df -h
df: /run/user/1000/doc: Операция не позволена
Файл.система   Размер Использовано  Дост Использовано% Cмонтировано в
udev             2,8G            0  2,8G            0% /dev
tmpfs            580M         1,2M  579M            1% /run
/dev/sda5         59G          16G   41G           28% /
tmpfs            2,9G            0  2,9G            0% /dev/shm
tmpfs            5,0M         4,0K  5,0M            1% /run/lock
tmpfs            2,9G            0  2,9G            0% /sys/fs/cgroup
/dev/loop0       111M         111M     0          100% /snap/core/12834
/dev/loop1        88M          88M     0          100% /snap/sqlitebrowser/3233
/dev/sda1        511M         4,0K  511M            1% /boot/efi
tmpfs            580M          24K  580M            1% /run/user/1000

#Разделы можно фильтровать c помощью ключа -x и ему указать тип файловой системы, который НЕ надо выводить. Например:
#Если не вдаваться в подробности, то tmpfs - память выделенная в ОЗУ.
df -hx tmpfs
df: /run/user/1000/doc: Операция не позволена
Файл.система   Размер Использовано  Дост Использовано% Cмонтировано в
udev             2,8G            0  2,8G            0% /dev
/dev/sda5         59G          16G   41G           28% /
/dev/loop0       111M         111M     0          100% /snap/core/12834
/dev/loop1        88M          88M     0          100% /snap/sqlitebrowser/3233
/dev/sda1        511M         4,0K  511M            1% /boot/efi

#Ключ -H всё выводит в гигабайтах.
#Ключ -a выводит всевозможные файловые системы, и виртуальные и недоступные и так далее.
#Ключ -P выводит всё в формате Posix, понятия не имею что это (Это как-то там очень тесно связано с переносом кода на другие платформы) Крч, в текстовых документах абсолютно бесполезная штука.
#Ключ -t выводит именно указанные файловые системы.

df -Hx tmpfs
df: /run/user/1000/doc: Операция не позволена
Файл.система   Размер Использовано  Дост Использовано% Cмонтировано в
udev             3,0G            0  3,0G            0% /dev
/dev/sda5         63G          17G   44G           28% /
/dev/loop0       116M         116M     0          100% /snap/core/12834
/dev/loop1        92M          92M     0          100% /snap/sqlitebrowser/3233
/dev/sda1        536M         4,1k  536M            1% /boot/efi

rokivals@RoKi:~/Документы/Информатика/Лабы$ df -Ht tmpfs
Файл.система   Размер Использовано  Дост Использовано% Cмонтировано в
tmpfs            609M         1,2M  607M            1% /run
tmpfs            3,1G            0  3,1G            0% /dev/shm
tmpfs            5,3M         4,1k  5,3M            1% /run/lock
tmpfs            3,1G            0  3,1G            0% /sys/fs/cgroup
tmpfs            609M          25k  609M            1% /run/user/1000

----------------------------------PASTE-------------------------------------------
#Самая простая программа, используемая для слияния строк. Берётся два файла или консольный ввод и построчно складываются строки в одну.
#Ключом -d можно изменить разделитель между строками.

paste file2 file3
Varian avarian0@newyorker.com Female Western New York $535,304.73	итого 72
Merrell nmerrell1@ted.com Female Finger Lakes $309,033.10	drwxrwxr-x 2 rokivals rokivals  4096 апр 23 00:41 .
Friett hfriett2@dagondesign.com Female Southern Tier $461,664.44	drwxrwxr-x 4 rokivals rokivals  4096 апр 21 17:09 ..
Venmore tvenmore3@gmpg.org Female Central New York $175,818.02	-rw-rw-r-- 1 rokivals rokivals 49282 апр 23 00:21 1984
Sealeaf dsealeaf4@nps.gov Female North Country $126,690.15	-rw-rw-r-- 1 rokivals rokivals   440 апр 23 00:25 file1
Bezley fbezley5@lulu.com Male Mohawk Valley $366,733.78	-rw-rw-r-- 1 rokivals rokivals   434 апр 22 00:04 file2
Standen ustanden6@geocities.jp Female Capital District $674,634.93	-rw-rw-r-- 1 rokivals rokivals     0 апр 23 00:41 file3
	-rw-rw-r-- 1 rokivals rokivals   171 апр 22 00:54 file4
	-rw-rw-r-- 1 rokivals rokivals     0 апр 23 00:41 file5

#Наглядный пример использования ключа.
paste -d'\t' file2 file3
Varian avarian0@newyorker.com Female Western New York $535,304.73	итого 72
Merrell nmerrell1@ted.com Female Finger Lakes $309,033.10	drwxrwxr-x 2 rokivals rokivals  4096 апр 23 00:41 .
Friett hfriett2@dagondesign.com Female Southern Tier $461,664.44	drwxrwxr-x 4 rokivals rokivals  4096 апр 21 17:09 ..
Venmore tvenmore3@gmpg.org Female Central New York $175,818.02	-rw-rw-r-- 1 rokivals rokivals 49282 апр 23 00:21 1984
Sealeaf dsealeaf4@nps.gov Female North Country $126,690.15	-rw-rw-r-- 1 rokivals rokivals   440 апр 23 00:25 file1
Bezley fbezley5@lulu.com Male Mohawk Valley $366,733.78	-rw-rw-r-- 1 rokivals rokivals   434 апр 22 00:04 file2
Standen ustanden6@geocities.jp Female Capital District $674,634.93	-rw-rw-r-- 1 rokivals rokivals     0 апр 23 00:41 file3
	-rw-rw-r-- 1 rokivals rokivals   171 апр 22 00:54 file4
	-rw-rw-r-- 1 rokivals rokivals     0 апр 23 00:41 file5
----------------------------------MKTEMP-------------------------------------------
#Команда, создающая временные файлы или каталоги в системе. Может использоваться для тестов чего-угодно.
#Удобен своей рандомизацией имени файла, что не приведёт к затратам времени на создание файла через touch.
#Все файлы создаются в спец каталоге, который очищается после перегрузки системы.
mktemp
/tmp/tmp.KYA2Zkp3gf

#Мы видим, что создался файл с абсолютно рандомным именем. Мы можем указать своё:
mktemp aoawdaXXX
aoawdaZAn
#Для этого нужно в конце имени указать не мене трёх последовательных символов X. Обратите внимание, что они в дальнейшем заменяются на рандомные значения. Это называется суффикс.
#Суффикс мы можем указать свой.
mktemp aoawdaXXX --suffix=MAI
aoawdadrPMAI












